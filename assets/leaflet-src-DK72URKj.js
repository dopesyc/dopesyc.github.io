function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var leafletSrc$1 = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var leafletSrc = leafletSrc$1.exports;
var hasRequiredLeafletSrc;
function requireLeafletSrc() {
  if (hasRequiredLeafletSrc) return leafletSrc$1.exports;
  hasRequiredLeafletSrc = 1;
  (function(module, exports) {
    (function(global, factory) {
      factory(exports);
    })(leafletSrc, function(exports2) {
      var version = "1.9.4";
      function extend(dest) {
        var i, j, len, src;
        for (j = 1, len = arguments.length; j < len; j++) {
          src = arguments[j];
          for (i in src) {
            dest[i] = src[i];
          }
        }
        return dest;
      }
      var create$2 = Object.create || /* @__PURE__ */ function() {
        function F() {
        }
        return function(proto) {
          F.prototype = proto;
          return new F();
        };
      }();
      function bind(fn, obj) {
        var slice = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj) {
        if (!("_leaflet_id" in obj)) {
          obj["_leaflet_id"] = ++lastId;
        }
        return obj._leaflet_id;
      }
      function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x, range, includeMax) {
        var max = range[1], min = range[0], d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow) / pow;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim(str).split(/\s+/);
      }
      function setOptions(obj, options) {
        if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
          obj.options = obj.options ? create$2(obj.options) : {};
        }
        for (var i in options) {
          obj.options[i] = options[i];
        }
        return obj.options;
      }
      function getParamString(obj, existingUrl, uppercase) {
        var params = [];
        for (var i in obj) {
          params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray = Array.isArray || function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
          if (array[i] === el) {
            return i;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
        window.clearTimeout(id);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind(fn, context));
        }
      }
      function cancelAnimFrame(id) {
        if (id) {
          cancelFn.call(window, id);
        }
      }
      var Util = {
        __proto__: null,
        extend,
        create: create$2,
        bind,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle,
        wrapNum,
        falseFn,
        formatNum,
        trim,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i in this) {
          if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
            NewClass[i] = this[i];
          }
        }
        if (props.statics) {
          extend(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend.apply(null, [proto].concat(props.includes));
        }
        extend(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
            proto._initHooks[i2].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options) {
        extend(this.prototype.options, options);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray(includes) ? includes : [includes];
        for (var i = 0; i < includes.length; i++) {
          if (includes[i] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context);
            }
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(types, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types === "object") {
            for (var type in types) {
              this._off(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            var removeAll = arguments.length === 1;
            for (var i = 0, len = types.length; i < len; i++) {
              if (removeAll) {
                this._off(types[i]);
              } else {
                this._off(types[i], fn, context);
              }
            }
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index2 = this._listens(type, fn, context);
          if (index2 !== false) {
            var listener = listeners[index2];
            if (this._firingCount) {
              listener.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index2, 1);
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i = 0, len = listeners.length; i < len; i++) {
                var l = listeners[i];
                var fn = l.fn;
                if (l.once) {
                  this.off(type, fn, l.ctx);
                }
                fn.call(l.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id in this._eventParents) {
              if (this._eventParents[id].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        // returns the index (number) or false
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i = 0, len = listeners.length; i < len; i++) {
            if (listeners[i].fn === fn && listeners[i].ctx === context) {
              return i;
            }
          }
          return false;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn, true);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context, true);
            }
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(obj) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj)] = obj;
          return this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(obj) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj)];
          }
          return this;
        },
        _propagateEvent: function(e) {
          for (var id in this._eventParents) {
            this._eventParents[id].fire(e.type, extend({
              layer: e.target,
              propagatedFrom: e.target
            }, e), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point(x, y, round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
      }
      var trunc = Math.trunc || function(v) {
        return v > 0 ? Math.floor(v) : Math.ceil(v);
      };
      Point.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new Point(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(point) {
          return this.clone()._add(toPoint(point));
        },
        _add: function(point) {
          this.x += point.x;
          this.y += point.y;
          return this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(point) {
          return this.clone()._subtract(toPoint(point));
        },
        _subtract: function(point) {
          this.x -= point.x;
          this.y -= point.y;
          return this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(point) {
          return new Point(this.x * point.x, this.y * point.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(point) {
          return new Point(this.x / point.x, this.y / point.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(point) {
          point = toPoint(point);
          var x = point.x - this.x, y = point.y - this.y;
          return Math.sqrt(x * x + y * y);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(point) {
          point = toPoint(point);
          return point.x === this.x && point.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(point) {
          point = toPoint(point);
          return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint(x, y, round) {
        if (x instanceof Point) {
          return x;
        }
        if (isArray(x)) {
          return new Point(x[0], x[1]);
        }
        if (x === void 0 || x === null) {
          return x;
        }
        if (typeof x === "object" && "x" in x && "y" in x) {
          return new Point(x.x, x.y);
        }
        return new Point(x, y, round);
      }
      function Bounds(a, b) {
        if (!a) {
          return;
        }
        var points = b ? [a, b] : a;
        for (var i = 0, len = points.length; i < len; i++) {
          this.extend(points[i]);
        }
      }
      Bounds.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var min2, max2;
          if (!obj) {
            return this;
          }
          if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
            min2 = max2 = toPoint(obj);
          } else {
            obj = toBounds(obj);
            min2 = obj.min;
            max2 = obj.max;
            if (!min2 || !max2) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min2.clone();
            this.max = max2.clone();
          } else {
            this.min.x = Math.min(min2.x, this.min.x);
            this.max.x = Math.max(max2.x, this.max.x);
            this.min.y = Math.min(min2.y, this.min.y);
            this.max.y = Math.max(max2.y, this.max.y);
          }
          return this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(round) {
          return toPoint(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return toPoint(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return toPoint(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          var min, max;
          if (typeof obj[0] === "number" || obj instanceof Point) {
            obj = toPoint(obj);
          } else {
            obj = toBounds(obj);
          }
          if (obj instanceof Bounds) {
            min = obj.min;
            max = obj.max;
          } else {
            min = max = obj;
          }
          return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
          return xIntersects && yIntersects;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
          return xOverlaps && yOverlaps;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
          return toBounds(
            toPoint(min.x - heightBuffer, min.y - widthBuffer),
            toPoint(max.x + heightBuffer, max.y + widthBuffer)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a, b) {
        if (!a || a instanceof Bounds) {
          return a;
        }
        return new Bounds(a, b);
      }
      function LatLngBounds(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i = 0, len = latlngs.length; i < len; i++) {
          this.extend(latlngs[i]);
        }
      }
      LatLngBounds.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(obj) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLng) {
            sw2 = obj;
            ne2 = obj;
          } else if (obj instanceof LatLngBounds) {
            sw2 = obj._southWest;
            ne2 = obj._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng(sw2.lat, sw2.lng);
            this._northEast = new LatLng(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds(
            new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new LatLng(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new LatLng(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new LatLng(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(obj) {
          if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
            obj = toLatLng(obj);
          } else {
            obj = toLatLngBounds(obj);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj instanceof LatLngBounds) {
            sw2 = obj.getSouthWest();
            ne2 = obj.getNorthEast();
          } else {
            sw2 = ne2 = obj;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a, b) {
        if (a instanceof LatLngBounds) {
          return a;
        }
        return new LatLngBounds(a, b);
      }
      function LatLng(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(obj, maxMargin) {
          if (!obj) {
            return false;
          }
          obj = toLatLng(obj);
          var margin = Math.max(
            Math.abs(this.lat - obj.lat),
            Math.abs(this.lng - obj.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a, b, c) {
        if (a instanceof LatLng) {
          return a;
        }
        if (isArray(a) && typeof a[0] !== "object") {
          if (a.length === 3) {
            return new LatLng(a[0], a[1], a[2]);
          }
          if (a.length === 2) {
            return new LatLng(a[0], a[1]);
          }
          return null;
        }
        if (a === void 0 || a === null) {
          return a;
        }
        if (typeof a === "object" && "lat" in a) {
          return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
        }
        if (b === void 0) {
          return null;
        }
        return new LatLng(a, b, c);
      }
      var CRS = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale2);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(point, zoom2) {
          var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
          return this.projection.unproject(untransformedPoint);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(point) {
          return this.projection.unproject(point);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(scale2) {
          return Math.log(scale2 / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
          return new Bounds(min, max);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: false,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng(lat, lng, alt);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds(newSw, newNe);
        }
      };
      var Earth = extend({}, CRS, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return this.R * c;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
          return new Point(
            this.R * latlng.lng * d,
            this.R * Math.log((1 + sin) / (1 - sin)) / 2
          );
        },
        unproject: function(point) {
          var d = 180 / Math.PI;
          return new LatLng(
            (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
            point.x * d / this.R
          );
        },
        bounds: function() {
          var d = earthRadius * Math.PI;
          return new Bounds([-d, -d], [d, d]);
        }()
      };
      function Transformation(a, b, c, d) {
        if (isArray(a)) {
          this._a = a[0];
          this._b = a[1];
          this._c = a[2];
          this._d = a[3];
          return;
        }
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
      }
      Transformation.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(point, scale2) {
          return this._transform(point.clone(), scale2);
        },
        // destructive transform (faster)
        _transform: function(point, scale2) {
          scale2 = scale2 || 1;
          point.x = scale2 * (this._a * point.x + this._b);
          point.y = scale2 * (this._c * point.y + this._d);
          return point;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(point, scale2) {
          scale2 = scale2 || 1;
          return new Point(
            (point.x / scale2 - this._b) / this._a,
            (point.y / scale2 - this._d) / this._c
          );
        }
      };
      function toTransformation(a, b, c, d) {
        return new Transformation(a, b, c, d);
      }
      var EPSG3857 = extend({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG900913 = extend({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function pointsToPath(rings, closed) {
        var str = "", i, j, len, len2, points, p;
        for (i = 0, len = rings.length; i < len; i++) {
          points = rings[i];
          for (j = 0, len2 = points.length; j < len2; j++) {
            p = points[j];
            str += (j ? "L" : "M") + p.x + " " + p.y;
          }
          str += closed ? Browser.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style = document.documentElement.style;
      var ie = "ActiveXObject" in window;
      var ielt9 = ie && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains("webkit");
      var android = userAgentContains("android");
      var android23 = userAgentContains("android 2") || userAgentContains("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome = !edge && userAgentContains("chrome");
      var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
      var safari = !chrome && userAgentContains("safari");
      var phantom = userAgentContains("phantom");
      var opera12 = "OTransition" in style;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie && "transition" in style;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e) {
        }
        return supportsPassiveOption;
      }();
      var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
      }();
      var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$1 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }();
      var vml = !svg$1 && function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e) {
          return false;
        }
      }();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser = {
        ie,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e) {
        _pointers[e.pointerId] = e;
      }
      function _globalPointerMove(e) {
        if (_pointers[e.pointerId]) {
          _pointers[e.pointerId] = e;
        }
      }
      function _globalPointerUp(e) {
        delete _pointers[e.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e.touches = [];
        for (var i in _pointers) {
          e.touches.push(_pointers[i]);
        }
        e.changedTouches = [e];
        handler(e);
      }
      function _onPointerStart(handler, e) {
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e);
        }
        _handlePointer(handler, e);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i;
        for (i in event) {
          prop = event[i];
          newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay = 200;
      function addDoubleTapListener(obj, handler) {
        obj.addEventListener("dblclick", handler);
        var last = 0, detail;
        function simDblclick(e) {
          if (e.detail !== 1) {
            detail = e.detail;
            return;
          }
          if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path = getPropagationPath(e);
          if (path.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now = Date.now();
          if (now - last <= delay) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e));
            }
          } else {
            detail = 1;
          }
          last = now;
        }
        obj.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj, handlers) {
        obj.removeEventListener("dblclick", handlers.dblclick);
        obj.removeEventListener("click", handlers.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get(id) {
        return typeof id === "string" ? document.getElementById(id) : id;
      }
      function getStyle(el, style2) {
        var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
        if ((!value || value === "auto") && document.defaultView) {
          var css = document.defaultView.getComputedStyle(el, null);
          value = css ? css[style2] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name) {
        if (el.classList !== void 0) {
          return el.classList.contains(name);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
      }
      function addClass(el, name) {
        if (el.classList !== void 0) {
          var classes = splitWords(name);
          for (var i = 0, len = classes.length; i < len; i++) {
            el.classList.add(classes[i]);
          }
        } else if (!hasClass(el, name)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name);
        }
      }
      function removeClass(el, name) {
        if (el.classList !== void 0) {
          el.classList.remove(name);
        } else {
          setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
        }
      }
      function setClass(el, name) {
        if (el.className.baseVal === void 0) {
          el.className = name;
        } else {
          el.className.baseVal = name;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter = el.filters.item(filterName);
        } catch (e) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = value !== 100;
          filter.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style2 = document.documentElement.style;
        for (var i = 0; i < props.length; i++) {
          if (props[i] in style2) {
            return props[i];
          }
        }
        return false;
      }
      function setTransform(el, offset, scale2) {
        var pos = offset || new Point(0, 0);
        el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
      }
      function setPosition(el, point) {
        el._leaflet_pos = point;
        if (Browser.any3d) {
          setTransform(el, point);
        } else {
          el.style.left = point.x + "px";
          el.style.top = point.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style2 = document.documentElement.style;
            _userSelect = style2[userSelectProperty];
            style2[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element) {
        while (element.tabIndex === -1) {
          element = element.parentNode;
        }
        if (!element.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element) {
        do {
          element = element.parentNode;
        } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
      }
      function getScale(element) {
        var rect = element.getBoundingClientRect();
        return {
          x: rect.width / element.offsetWidth || 1,
          y: rect.height / element.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get,
        getStyle,
        create: create$1,
        remove,
        empty,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale
      };
      function on(obj, types, fn, context) {
        if (types && typeof types === "object") {
          for (var type in types) {
            addOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            addOne(obj, types[i], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj, types, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj);
          delete obj[eventsKey];
        } else if (types && typeof types === "object") {
          for (var type in types) {
            removeOne(obj, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          if (arguments.length === 2) {
            batchRemove(obj, function(type2) {
              return indexOf(types, type2) !== -1;
            });
          } else {
            for (var i = 0, len = types.length; i < len; i++) {
              removeOne(obj, types[i], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj, filterFn) {
        for (var id in obj[eventsKey]) {
          var type = id.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj, type, null, null, id);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj, type, fn, context) {
        var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj[eventsKey] && obj[eventsKey][id]) {
          return this;
        }
        var handler = function(e) {
          return fn.call(context || obj, e || window.event);
        };
        var originalHandler = handler;
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj, handler);
        } else if ("addEventListener" in obj) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e) {
              e = e || window.event;
              if (isExternalTarget(obj, e)) {
                originalHandler(e);
              }
            };
            obj.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj.addEventListener(type, originalHandler, false);
          }
        } else {
          obj.attachEvent("on" + type, handler);
        }
        obj[eventsKey] = obj[eventsKey] || {};
        obj[eventsKey][id] = handler;
      }
      function removeOne(obj, type, fn, context, id) {
        id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj[eventsKey] && obj[eventsKey][id];
        if (!handler) {
          return this;
        }
        if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj, type, handler);
        } else if (Browser.touch && type === "dblclick") {
          removeDoubleTapListener(obj, handler);
        } else if ("removeEventListener" in obj) {
          obj.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj.detachEvent("on" + type, handler);
        }
        obj[eventsKey][id] = null;
      }
      function stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else if (e.originalEvent) {
          e.originalEvent._stopped = true;
        } else {
          e.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        return this;
      }
      function stop(e) {
        preventDefault(e);
        stopPropagation(e);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path = [];
        var el = ev.target;
        while (el) {
          path.push(el);
          el = el.parentNode;
        }
        return path;
      }
      function getMousePosition(e, container) {
        if (!container) {
          return new Point(e.clientX, e.clientY);
        }
        var scale2 = getScale(container), offset = scale2.boundingClientRect;
        return new Point(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (e.clientX - offset.left) / scale2.x - container.clientLeft,
          (e.clientY - offset.top) / scale2.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e) {
        return Browser.edge ? e.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : (
            // Pixels
            e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : (
              // Lines
              e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : (
                // Pages
                e.deltaX || e.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : (
                      // Legacy Moz lines
                      e.detail ? e.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function isExternalTarget(el, e) {
        var related = e.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +/* @__PURE__ */ new Date();
          this.fire("start");
          this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round) {
          var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress, round) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress));
          if (round) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower);
        }
      });
      var Map = Evented.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: EPSG3857,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: true,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: true,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: true,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: true
        },
        initialize: function(id, options) {
          options = setOptions(this, options);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id);
          this._initLayout();
          this._onResize = bind(this._onResize, this);
          this._initEvents();
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          if (options.zoom !== void 0) {
            this._zoom = this._limitZoom(options.zoom);
          }
          if (options.center && options.zoom !== void 0) {
            this.setView(toLatLng(options.center), options.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(center, zoom2, options) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options = options || {};
          this._stop();
          if (this._loaded && !options.reset && options !== true) {
            if (options.animate !== void 0) {
              options.zoom = extend({ animate: options.animate }, options.zoom);
              options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
          return this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(zoom2, options) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options });
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(delta, options) {
          delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(latlng, zoom2, options) {
          var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options });
        },
        _getBoundsCenterZoom: function(bounds, options) {
          options = options || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(bounds, options) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.setView(target.center, target.zoom, options);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(options) {
          return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(center, options) {
          return this.setView(center, this._zoom, { pan: options });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(offset, options) {
          offset = toPoint(offset).round();
          options = options || {};
          if (!offset.x && !offset.y) {
            return this.fire("moveend");
          }
          if (options.animate !== true && !this.getSize().contains(offset)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options.noMoveStart) {
            this.fire("movestart");
          }
          if (options.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset).round();
            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
          } else {
            this._rawPanBy(offset);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(targetCenter, targetZoom, options) {
          options = options || {};
          if (options.animate === false || !Browser.any3d) {
            return this.setView(targetCenter, targetZoom, options);
          }
          this._stop();
          var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
          function r(i) {
            var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
            var log = sq < 1e-9 ? -18 : Math.log(sq);
            return log;
          }
          function sinh(n) {
            return (Math.exp(n) - Math.exp(-n)) / 2;
          }
          function cosh(n) {
            return (Math.exp(n) + Math.exp(-n)) / 2;
          }
          function tanh(n) {
            return sinh(n) / cosh(n);
          }
          var r0 = r(0);
          function w(s) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s));
          }
          function u(s) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
          }
          function easeOut(t) {
            return 1 - Math.pow(1 - t, 1.5);
          }
          var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
          function frame() {
            var t = (Date.now() - start) / duration, s = easeOut(t) * S;
            if (t <= 1) {
              this._flyToFrame = requestAnimFrame(frame, this);
              this._move(
                this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                this.getScaleZoom(w0 / w(s), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options.noMoveStart);
          frame.call(this);
          return this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(bounds, options) {
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.flyTo(target.center, target.zoom, options);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(bounds, options) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options);
          }
          this._enforcingBounds = false;
          return this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(latlng, options) {
          options = options || {};
          var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
            this.panTo(this.unproject(pixelCenter), options);
            this._enforcingBounds = false;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(options) {
          if (!this._loaded) {
            return this;
          }
          options = extend({
            animate: false,
            pan: true
          }, options === true ? { animate: true } : options);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
          if (!offset.x && !offset.y) {
            return this;
          }
          if (options.animate && options.pan) {
            this.panBy(offset);
          } else {
            if (options.pan) {
              this._rawPanBy(offset);
            }
            this.fire("move");
            if (options.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(options) {
          options = this._locateOptions = extend({
            timeout: 1e4,
            watch: false
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, options);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
          if (options.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options);
          }
          return this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
          if (options.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i in pos.coords) {
            if (typeof pos.coords[i] === "number") {
              data[i] = pos.coords[i];
            }
          }
          this.fire("locationfound", data);
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(name, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name]) {
            handler.enable();
          }
          return this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i;
          for (i in this._layers) {
            this._layers[i].remove();
          }
          for (i in this._panes) {
            remove(this._panes[i]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(name, container) {
          var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name) {
            this._panes[name] = pane;
          }
          return pane;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds(sw, ne);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale2, zoom2);
          if (snap) {
            zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(scale2, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(point, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint(point), zoom2);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(point) {
          var projectedPoint = toPoint(point).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(point) {
          return toPoint(point).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(point) {
          return toPoint(point).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(point) {
          var layerPoint = this.containerPointToLayerPoint(toPoint(point));
          return this.layerPointToLatLng(layerPoint);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(e) {
          return getMousePosition(e, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(e) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(e) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        // map initialization methods
        _initContainer: function(id) {
          var container = this._container = get(id);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
          addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position = getStyle(container, "position");
          if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e) {
          var el = e.target || e.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e, type, canvasTargets) {
          if (e.type === "click") {
            var synth = extend({}, e);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i = 0; i < canvasTargets.length; i++) {
              if (canvasTargets[i].listens(type, true)) {
                filtered.push(canvasTargets[i]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e);
          }
          var target = targets[0];
          var data = {
            originalEvent: e
          };
          if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i = 0; i < targets.length; i++) {
            targets[i].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj) {
          obj = obj.dragging && obj.dragging.enabled() ? obj : this;
          return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i = 0, len = this._handlers.length; i < len; i++) {
            this._handlers[i].disable();
          }
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset), zoom2);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(offset, bounds) {
          if (!bounds) {
            return offset;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
          return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
          if (snap) {
            zoom2 = Math.round(zoom2 / snap) * snap;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
          var offset = this._getCenterOffset(center)._trunc();
          if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
            return false;
          }
          this.panBy(offset, options);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e) {
            var prop = TRANSFORM, transform = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
            if (transform === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c = this.getCenter(), z = this.getZoom();
          setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        },
        _catchTransitionEnd: function(e) {
          if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options) {
          if (this._animatingZoom) {
            return true;
          }
          options = options || {};
          if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
          if (options.animate !== true && !this.getSize().contains(offset)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id, options) {
        return new Map(id, options);
      }
      var Control = Class.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(position) {
          var map = this._map;
          if (map) {
            map.removeControl(this);
          }
          this.options.position = position;
          if (map) {
            map.addControl(this);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(map) {
          this.remove();
          this._map = map;
          var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e) {
          if (this._map && e && e.screenX > 0 && e.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control = function(options) {
        return new Control(options);
      };
      Map.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(control2) {
          control2.addTo(this);
          return this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(control2) {
          control2.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l + vSide + " " + l + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i in this._controlCorners) {
            remove(this._controlCorners[i]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: true,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: true,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: false,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: false,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options) {
          setOptions(this, options);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i in baseLayers) {
            this._addLayer(baseLayers[i], i);
          }
          for (i in overlays) {
            this._addLayer(overlays[i], i, true);
          }
        },
        onAdd: function(map) {
          this._initLayout();
          this._update();
          this._map = map;
          map.on("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map) {
          Control.prototype.addTo.call(this, map);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.off("add remove", this._onLayerChange, this);
          }
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(layer, name) {
          this._addLayer(layer, name);
          return this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(layer, name) {
          this._addLayer(layer, name, true);
          return this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj = this._getLayer(stamp(layer));
          if (obj) {
            this._layers.splice(this._layers.indexOf(obj), 1);
          }
          return this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link = this._layersLink = create$1("a", className + "-toggle", container);
          link.href = "#";
          link.title = "Layers";
          link.setAttribute("role", "button");
          on(link, {
            keydown: function(e) {
              if (e.keyCode === 13) {
                this._expandSafely();
              }
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(e) {
              preventDefault(e);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id) {
          for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i] && stamp(this._layers[i].layer) === id) {
              return this._layers[i];
            }
          }
        },
        _addLayer: function(layer, name, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind(function(a, b) {
              return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty(this._baseLayersList);
          empty(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
          for (i = 0; i < this._layers.length; i++) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
            baseLayersCount += !obj.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj = this._getLayer(stamp(e.target));
          var type = obj.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj);
          }
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(name, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
          if (obj.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj.layer);
          on(input, "click", this._onInputClick, this);
          var name = document.createElement("span");
          name.innerHTML = " " + obj.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i = 0; i < removedLayers.length; i++) {
            if (this._map.hasLayer(removedLayers[i])) {
              this._map.removeLayer(removedLayers[i]);
            }
          }
          for (i = 0; i < addedLayers.length; i++) {
            if (!this._map.hasLayer(addedLayers[i])) {
              this._map.addLayer(addedLayers[i]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
      };
      var Zoom = Control.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
          this._zoomInButton = this._createButton(
            options.zoomInText,
            options.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options.zoomOutText,
            options.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map) {
          map.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html, title, className, container, fn) {
          var link = create$1("a", className, container);
          link.innerHTML = html;
          link.href = "#";
          link.title = title;
          link.setAttribute("role", "button");
          link.setAttribute("aria-label", title);
          disableClickPropagation(link);
          on(link, "click", stop);
          on(link, "click", fn, this);
          on(link, "click", this._refocusOnMap, this);
          return link;
        },
        _updateDisabled: function() {
          var map = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map._zoom === map.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map._zoom === map.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map.mergeOptions({
        zoomControl: true
      });
      Map.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options) {
        return new Zoom(options);
      };
      var Scale = Control.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: true,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: true
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(map) {
          var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
          this._addScales(options, className + "-line", container);
          map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
          map.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map) {
          map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
          if (options.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map = this._map, y = map.getSize().y / 2;
          var maxMeters = map.distance(
            map.containerPointToLatLng([0, y]),
            map.containerPointToLatLng([this.options.maxWidth, y])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale2, text, ratio) {
          scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale2.innerHTML = text;
        },
        _getRoundNum: function(num) {
          var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
          d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
          return pow10 * d;
        }
      });
      var scale = function(options) {
        return new Scale(options);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options) {
          setOptions(this, options);
          this._attributions = {};
        },
        onAdd: function(map) {
          map.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i in map._layers) {
            if (map._layers[i].getAttribution) {
              this.addAttribution(map._layers[i].getAttribution());
            }
          }
          this._update();
          map.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map) {
          map.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(prefix) {
          this.options.prefix = prefix;
          this._update();
          return this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (!this._attributions[text]) {
            this._attributions[text] = 0;
          }
          this._attributions[text]++;
          this._update();
          return this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (this._attributions[text]) {
            this._attributions[text]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i in this._attributions) {
            if (this._attributions[i]) {
              attribs.push(i);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map.mergeOptions({
        attributionControl: true
      });
      Map.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options) {
        return new Attribution(options);
      };
      Control.Layers = Layers;
      Control.Zoom = Zoom;
      Control.Scale = Scale;
      Control.Attribution = Attribution;
      control.layers = layers;
      control.zoom = zoom;
      control.scale = scale;
      control.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map) {
          this._map = map;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Handler.addTo = function(map, name) {
        map.addHandler(name, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(element, dragStartTarget, preventOutline2, options) {
          setOptions(this, options);
          this._element = element;
          this._dragStartTarget = dragStartTarget || element;
          this._preventOutline = preventOutline2;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e.touches && e.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale(sizedParent);
          var mouseevent = e.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e) {
          if (!this._enabled) {
            return;
          }
          if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset.x && !offset.y) {
            return;
          }
          if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
            return;
          }
          offset.x /= this._parentScale.x;
          offset.y /= this._parentScale.y;
          preventDefault(e);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e.target || e.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset);
          this._moving = true;
          this._lastEvent = e;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e = { originalEvent: this._lastEvent };
          this.fire("predrag", e);
          setPosition(this._element, this._newPos);
          this.fire("drag", e);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round) {
        var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
        for (i = 0, len = points.length; i < len; i++) {
          points[i]._code = _getBitCode(points[i], bounds);
        }
        for (k = 0; k < 4; k++) {
          edge2 = edges[k];
          clippedPoints = [];
          for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            a = points[i];
            b = points[j];
            if (!(a._code & edge2)) {
              if (b._code & edge2) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
              clippedPoints.push(a);
            } else if (!(b._code & edge2)) {
              p = _getEdgeIntersection(b, a, edge2, bounds, round);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i, j, p1, p2, f, area, x, y, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x = y = 0;
        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x / area, y / area];
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i = 0; i < coords.length; i++) {
          var latlng = toLatLng(coords[i]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p, p1, p2) {
        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
      }
      function closestPointOnSegment(p, p1, p2) {
        return _sqClosestPointOnSegment(p, p1, p2);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i, newPoints = [];
        for (i = 0; i < len; i++) {
          if (markers[i]) {
            newPoints.push(points[i]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index2, i, sqDist;
        for (i = first + 1; i <= last - 1; i++) {
          sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
          if (sqDist > maxSqDist) {
            index2 = i;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index2] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index2);
          _simplifyDPStep(points, markers, sqTolerance, index2, last);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i = 1, prev = 0, len = points.length; i < len; i++) {
          if (_sqDist(points[i], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i]);
            prev = i;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a, b, bounds, useLastCode, round) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a, b];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p = _getEdgeIntersection(a, b, codeOut, bounds, round);
          newCode = _getBitCode(p, bounds);
          if (codeOut === codeA) {
            a = p;
            codeA = newCode;
          } else {
            b = p;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a, b, code, bounds, round) {
        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
        if (code & 8) {
          x = a.x + dx * (max.y - a.y) / dy;
          y = max.y;
        } else if (code & 4) {
          x = a.x + dx * (min.y - a.y) / dy;
          y = min.y;
        } else if (code & 2) {
          x = max.x;
          y = a.y + dy * (max.x - a.x) / dx;
        } else if (code & 1) {
          x = min.x;
          y = a.y + dy * (min.x - a.x) / dx;
        }
        return new Point(x, y, round);
      }
      function _getBitCode(p, bounds) {
        var code = 0;
        if (p.x < bounds.min.x) {
          code |= 1;
        } else if (p.x > bounds.max.x) {
          code |= 2;
        }
        if (p.y < bounds.min.y) {
          code |= 4;
        } else if (p.y > bounds.max.y) {
          code |= 8;
        }
        return code;
      }
      function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
        if (dot > 0) {
          t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
          if (t > 1) {
            x = p2.x;
            y = p2.y;
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = p.x - x;
        dy = p.y - y;
        return sqDist ? dx * dx + dy * dy : new Point(x, y);
      }
      function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i = 0, dist = 0; i < len - 1; i++) {
            p1 = points[i];
            p2 = points[i + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p2.x - ratio * (p2.x - p1.x),
                p2.y - ratio * (p2.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point(latlng.lng, latlng.lat);
        },
        unproject: function(point) {
          return new LatLng(point.y, point.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
          var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
          y = -r * Math.log(Math.max(ts, 1e-10));
          return new Point(latlng.lng * d * r, y);
        },
        unproject: function(point) {
          var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
            con = e * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng(phi * d, point.x * d / r);
        }
      };
      var index = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG4326 = extend({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend({}, CRS, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS.Earth = Earth;
      CRS.EPSG3395 = EPSG3395;
      CRS.EPSG3857 = EPSG3857;
      CRS.EPSG900913 = EPSG900913;
      CRS.EPSG4326 = EPSG4326;
      CRS.Simple = Simple;
      var Layer = Evented.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: true
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(map) {
          map.addLayer(this);
          return this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(obj) {
          if (obj) {
            obj.removeLayer(this);
          }
          return this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(name) {
          return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e) {
          var map = e.target;
          if (!map.hasLayer(this)) {
            return;
          }
          this._map = map;
          this._zoomAnimated = map._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map.on(events, this);
            this.once("remove", function() {
              map.off(events, this);
            }, this);
          }
          this.onAdd(map);
          this.fire("add");
          map.fire("layeradd", { layer: this });
        }
      });
      Map.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id = stamp(layer);
          if (this._layers[id]) {
            return this;
          }
          this._layers[id] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(layer) {
          var id = stamp(layer);
          if (!this._layers[id]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
          for (var i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id = stamp(layer);
          if (this._zoomBoundLayers[id]) {
            delete this._zoomBoundLayers[id];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i in this._zoomBoundLayers) {
            var options = this._zoomBoundLayers[i].options;
            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer.extend({
        initialize: function(layers2, options) {
          setOptions(this, options);
          this._layers = {};
          var i, len;
          if (layers2) {
            for (i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          }
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(layer) {
          var id = this.getLayerId(layer);
          this._layers[id] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(layer) {
          var id = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id]) {
            this._map.removeLayer(this._layers[id]);
          }
          delete this._layers[id];
          return this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i, layer;
          for (i in this._layers) {
            layer = this._layers[i];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map) {
          this.eachLayer(map.addLayer, map);
        },
        onRemove: function(map) {
          this.eachLayer(map.removeLayer, map);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(id) {
          return this._layers[id];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options) {
        return new LayerGroup(layers2, options);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(style2) {
          return this.invoke("setStyle", style2);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var bounds = new LatLngBounds();
          for (var id in this._layers) {
            var layer = this._layers[id];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup = function(layers2, options) {
        return new FeatureGroup(layers2, options);
      };
      var Icon = Class.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
          var src = this._getIconUrl(name);
          if (!src) {
            if (name === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name) {
          var options = this.options;
          var sizeOption = options[name + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
          img.className = "leaflet-marker-" + name + " " + (options.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size) {
            img.style.width = size.x + "px";
            img.style.height = size.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name) {
          return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
      });
      function icon(options) {
        return new Icon(options);
      }
      var IconDefault = Icon.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function(path) {
          var strip = function(str, re, idx) {
            var match = re.exec(str);
            return match && match[idx];
          };
          path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
          return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path = this._stripUrl(path);
          if (path) {
            return path;
          }
          var link = document.querySelector('link[href$="leaflet.css"]');
          if (!link) {
            return "";
          }
          return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker2) {
          this._marker = marker2;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e) {
          var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin).add(padding),
            bounds.max._subtract(origin).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker2._icon, this._draggable._newPos);
            this._onDrag(e);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDrag: function(e) {
          var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker2._latlng = latlng;
          e.latlng = latlng;
          e.oldLatLng = this._oldLatLng;
          marker2.fire("move", e).fire("drag", e);
        },
        _onDragEnd: function(e) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e);
        }
      });
      var Marker = Layer.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new IconDefault(),
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: true,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: false,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: false,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: true,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: false,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: false,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map) {
          this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(offset) {
          this.options.zIndexOffset = offset;
          return this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options.title) {
              icon2.title = options.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map = this._map;
          if (!map) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
          map.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker(latlng, options) {
        return new Marker(latlng, options);
      }
      var Path = Layer.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: true,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: false,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: true,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: true
        },
        beforeAdd: function(map) {
          this._renderer = map.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(style2) {
          setOptions(this, style2);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: true,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options) {
          var radius = options && options.radius || this._radius;
          Path.prototype.setStyle.call(this, options);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
          this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
      }
      var Circle = CircleMarker.extend({
        initialize: function(latlng, options, legacyOptions) {
          if (typeof options === "number") {
            options = extend({}, legacyOptions, { radius: options });
          }
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
          if (crs.distance === Earth.distance) {
            var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p.subtract(map.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
            this._radiusY = p.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle(latlng, options, legacyOptions) {
        return new Circle(latlng, options, legacyOptions);
      }
      var Polyline = Path.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: false
        },
        initialize: function(latlngs, options) {
          setOptions(this, options);
          this._setLatLngs(latlngs);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
          for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
            var points = this._parts[j];
            for (var i = 1, len = points.length; i < len; i++) {
              p1 = points[i - 1];
              p2 = points[i];
              var sqDist = closest(p, p1, p2, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p, p1, p2);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(latlngs) {
          var result = [], flat = isFlat(latlngs);
          for (var i = 0, len = latlngs.length; i < len; i++) {
            if (flat) {
              result[i] = toLatLng(latlngs[i]);
              this._bounds.extend(result[i]);
            } else {
              result[i] = this._convertLatLngs(latlngs[i]);
            }
          }
          return result;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w = this._clickTolerance(), p = new Point(w, w);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p),
            this._rawPxBounds.max.add(p)
          ]);
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(latlngs, result, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
          if (flat) {
            ring = [];
            for (i = 0; i < len; i++) {
              ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
              projectedBounds.extend(ring[i]);
            }
            result.push(ring);
          } else {
            for (i = 0; i < len; i++) {
              this._projectLatlngs(latlngs[i], result, projectedBounds);
            }
          }
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts = this._parts, i, j, k, len, len2, segment, points;
          for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
            points = this._rings[i];
            for (j = 0, len2 = points.length; j < len2 - 1; j++) {
              segment = clipSegment(points[j], points[j + 1], bounds, j, true);
              if (!segment) {
                continue;
              }
              parts[k] = parts[k] || [];
              parts[k].push(segment[0]);
              if (segment[1] !== points[j + 1] || j === len2 - 2) {
                parts[k].push(segment[1]);
                k++;
              }
            }
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          var parts = this._parts, tolerance = this.options.smoothFactor;
          for (var i = 0, len = parts.length; i < len; i++) {
            parts[i] = simplify(parts[i], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p, closed) {
          var i, j, k, len, len2, part, w = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              if (!closed && j === 0) {
                continue;
              }
              if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline(latlngs, options) {
        return new Polyline(latlngs, options);
      }
      Polyline._flat = _flat;
      var Polygon = Polyline.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
          if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
            result.pop();
          }
          return result;
        },
        _setLatLngs: function(latlngs) {
          Polyline.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
          bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
            clipped = clipPolygon(this._rings[i], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          var inside = false, part, p1, p2, i, j, k, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              p1 = part[j];
              p2 = part[k];
              if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
      });
      function polygon(latlngs, options) {
        return new Polygon(latlngs, options);
      }
      var GeoJSON = FeatureGroup.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(geojson, options) {
          setOptions(this, options);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(geojson) {
          var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
          if (features) {
            for (i = 0, len = features.length; i < len; i++) {
              feature = features[i];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options = this.options;
          if (options.filter && !options.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options.onEachFeature) {
            options.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(style2) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style2);
          }, this);
        },
        _setLayerStyle: function(layer, style2) {
          if (layer.setStyle) {
            if (typeof style2 === "function") {
              style2 = style2(layer.feature);
            }
            layer.setStyle(style2);
          }
        }
      });
      function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options);
          case "MultiPoint":
            for (i = 0, len = coords.length; i < len; i++) {
              latlng = _coordsToLatLng(coords[i]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline(latlngs, options);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon(latlngs, options);
          case "GeometryCollection":
            for (i = 0, len = geometry.geometries.length; i < len; i++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i],
                type: "Feature",
                properties: geojson.properties
              }, options);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i = 0, len = geometry.features.length; i < len; i++) {
              var featureLayer = geometryToLayer(geometry.features[i], options);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
      }
      function coordsToLatLng(coords) {
        return new LatLng(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i = 0, len = coords.length, latlng; i < len; i++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i = 0, len = latlngs.length; i < len; i++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker.include(PointToGeoJSON);
      Circle.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON(geojson, options) {
        return new GeoJSON(geojson, options);
      }
      var geoJson = geoJSON;
      var ImageOverlay = Layer.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(url, bounds, options) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind(this.fire, this, "load");
          img.onerror = bind(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e) {
          var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
          setTransform(this._image, offset, scale2);
        },
        _reset: function() {
          var image = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size = bounds.getSize();
          setPosition(image, bounds.min);
          image.style.width = size.x + "px";
          image.style.height = size.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
      };
      var VideoOverlay = ImageOverlay.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: true,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: true,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: true,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: false,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j = 0; j < sourceElements.length; j++) {
              sources.push(sourceElements[j].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i = 0; i < this._url.length; i++) {
            var source = create$1("source");
            source.src = this._url[i];
            vid.appendChild(source);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
      }
      var DivOverlay = Layer.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: false,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(options, source) {
          if (options && (options instanceof LatLng || isArray(options))) {
            this._latlng = toLatLng(options);
            setOptions(this, source);
          } else {
            setOptions(this, options);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(map) {
          map = arguments.length ? map : this._source._map;
          if (!map.hasLayer(this)) {
            map.addLayer(this);
          }
          return this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map) {
          this._zoomAnimated = map._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map) {
          if (map._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(content) {
          this._content = content;
          this.update();
          return this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id in layers2) {
              if (layers2[id]._map) {
                source = layers2[id];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node = this._contentNode;
          var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content === "string") {
            node.innerHTML = content;
          } else {
            while (node.hasChildNodes()) {
              node.removeChild(node.firstChild);
            }
            node.appendChild(content);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset = offset.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map.include({
        _initOverlay: function(OverlayClass, content, latlng, options) {
          var overlay = content;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options).setContent(content);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer.include({
        _initOverlay: function(OverlayClass, old, content, options) {
          var overlay = content;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options);
            overlay._source = this;
          } else {
            overlay = old && !options ? old : new OverlayClass(options, this);
            overlay.setContent(content);
          }
          return overlay;
        }
      });
      var Popup = DivOverlay.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: true,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: false,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: true,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: true,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: true,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(map) {
          map = arguments.length ? map : this._source._map;
          if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
            map.removeLayer(map._popup);
          }
          map._popup = this;
          return DivOverlay.prototype.openOn.call(this, map);
        },
        onAdd: function(map) {
          DivOverlay.prototype.onAdd.call(this, map);
          map.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map) {
          DivOverlay.prototype.onRemove.call(this, map);
          map.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix + "-tip-container", container);
          this._tip = create$1("div", prefix + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style2 = container.style;
          style2.width = "";
          style2.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style2.width = width + 1 + "px";
          style2.whiteSpace = "";
          style2.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style2.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size.x) {
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size.y) {
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup = function(options, source) {
        return new Popup(options, source);
      };
      Map.mergeOptions({
        closePopupOnClick: true
      });
      Map.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(popup2, latlng, options) {
          this._initOverlay(Popup, popup2, latlng, options).openOn(this);
          return this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(popup2) {
          popup2 = arguments.length ? popup2 : this._popup;
          if (popup2) {
            popup2.close();
          }
          return this;
        }
      });
      Layer.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(content, options) {
          this._popup = this._initOverlay(Popup, this._popup, content, options);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(content) {
          if (this._popup) {
            this._popup.setContent(content);
          }
          return this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e);
          var target = e.layer || e.target;
          if (this._popup._source === target && !(target instanceof Path)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e.latlng);
        },
        _movePopup: function(e) {
          this._popup.setLatLng(e.latlng);
        },
        _onKeyPress: function(e) {
          if (e.originalEvent.keyCode === 13) {
            this._openPopup(e);
          }
        }
      });
      var Tooltip = DivOverlay.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: false,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: false,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(map) {
          DivOverlay.prototype.onAdd.call(this, map);
          this.setOpacity(this.options.opacity);
          map.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map) {
          DivOverlay.prototype.onRemove.call(this, map);
          map.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip = function(options, source) {
        return new Tooltip(options, source);
      };
      Map.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(tooltip2, latlng, options) {
          this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
          return this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(tooltip2) {
          tooltip2.close();
          return this;
        }
      });
      Layer.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(content, options) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(content) {
          if (this._tooltip) {
            this._tooltip.setContent(content);
          }
          return this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e);
            });
            return;
          }
          this._tooltip._source = e.layer || e.target;
          this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
        },
        _moveTooltip: function(e) {
          var latlng = e.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: false,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
          if (options.html instanceof Element) {
            empty(div);
            div.appendChild(options.html);
          } else {
            div.innerHTML = options.html !== false ? options.html : "";
          }
          if (options.bgPos) {
            var bgPos = toPoint(options.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon(options) {
        return new DivIcon(options);
      }
      Icon.Default = IconDefault;
      var GridLayer = Layer.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Browser.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: true,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: false,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map) {
          map._addZoomLimit(this);
        },
        onRemove: function(map) {
          this._removeAllTiles();
          remove(this._container);
          map._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var s = this.options.tileSize;
          return s instanceof Point ? s : new Point(s, s);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
            zIndex = layers2[i].style.zIndex;
            if (layers2[i] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z in this._levels) {
            z = Number(z);
            if (this._levels[z].el.children.length || z === zoom2) {
              this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
              this._onUpdateLevel(z);
            } else {
              remove(this._levels[z].el);
              this._removeTilesAtZoom(z);
              this._onRemoveLevel(z);
              delete this._levels[z];
            }
          }
          var level = this._levels[zoom2], map = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map.getCenter(), map.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z in this._levels) {
            remove(this._levels[z].el);
            this._onRemoveLevel(Number(z));
            delete this._levels[z];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x, y, z, minZoom) {
          var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
          coords2.z = +z2;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z2 > minZoom) {
            return this._retainParent(x2, y2, z2, minZoom);
          }
          return false;
        },
        _retainChildren: function(x, y, z, maxZoom) {
          for (var i = 2 * x; i < 2 * x + 2; i++) {
            for (var j = 2 * y; j < 2 * y + 2; j++) {
              var coords = new Point(i, j);
              coords.z = z + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z + 1 < maxZoom) {
                this._retainChildren(i, j, z + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e) {
          var animating = e && (e.pinch || e.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e) {
          this._setView(e.center, e.zoom, true, e.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options = this.options;
          if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
            return options.minNativeZoom;
          }
          if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
            return options.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i in this._levels) {
            this._setZoomTransform(this._levels[i], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser.any3d) {
            setTransform(level.el, translate, scale2);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(center) {
          var map = this._map;
          if (!map) {
            return;
          }
          var zoom2 = this._clampZoom(map.getZoom());
          if (center === void 0) {
            center = map.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
              var coords = new Point(i, j);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a, b) {
            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < queue.length; i++) {
              this._addTile(queue[i], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
          return [nw, se];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(key) {
          var k = key.split(":"), coords = new Point(+k[0], +k[1]);
          coords.z = +k[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +/* @__PURE__ */ new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options) {
        return new GridLayer(options);
      }
      var TileLayer = GridLayer.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: false,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: false,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: false,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: false,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: false
        },
        initialize: function(url, options) {
          this._url = url;
          options = setOptions(this, options);
          if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
            options.tileSize = Math.floor(options.tileSize / 2);
            if (!options.zoomReverse) {
              options.zoomOffset++;
              options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
            } else {
              options.zoomOffset--;
              options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
            }
            options.minZoom = Math.max(0, options.minZoom);
          } else if (!options.zoomReverse) {
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
          } else {
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
          }
          if (typeof options.subdomains === "string") {
            options.subdomains = options.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(coords) {
          var data = {
            r: Browser.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser.ielt9) {
            setTimeout(bind(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e, tile);
        },
        _onTileRemove: function(e) {
          e.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index2];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var i, tile;
          for (i in this._tiles) {
            if (this._tiles[i].coords.z !== this._tileZoom) {
              tile = this._tiles[i].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i].coords;
                remove(tile);
                delete this._tiles[i];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer(url, options) {
        return new TileLayer(url, options);
      }
      var TileLayerWMS = TileLayer.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: false,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: false
        },
        initialize: function(url, options) {
          this._url = url;
          var wmsParams = extend({}, this.defaultWmsParams);
          for (var i in options) {
            if (!(i in this.options)) {
              wmsParams[i] = options[i];
            }
          }
          options = setOptions(this, options);
          var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map) {
          this._crs = this.options.crs || map.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer.prototype.onAdd.call(this, map);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(params, noRedraw) {
          extend(this.wmsParams, params);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
      }
      TileLayer.WMS = TileLayerWMS;
      tileLayer.wms = tileLayerWMS;
      var Renderer = Layer.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(options) {
          setOptions(this, options);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser.any3d) {
            setTransform(this._container, topLeftOffset, scale2);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id in this._layers) {
            this._layers[id]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id in this._layers) {
            this._layers[id]._project();
          }
        },
        _updatePaths: function() {
          for (var id in this._layers) {
            this._layers[id]._update();
          }
        },
        _update: function() {
          var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
          this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id in this._layers) {
            layer = this._layers[id];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
          setPosition(container, b.min);
          container.width = m * size.x;
          container.height = m * size.y;
          container.style.width = size.x + "px";
          container.style.height = size.y + "px";
          if (Browser.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b.min.x, -b.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order;
          }
          this._drawLast = order;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order = layer._order;
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
            for (i = 0; i < parts.length; i++) {
              dashValue = Number(parts[i]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i = 0; i < len; i++) {
            for (j = 0, len2 = parts[i].length; j < len2; j++) {
              p = parts[i][j];
              ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
          if (s !== 1) {
            ctx.save();
            ctx.scale(1, s);
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
          if (s !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options = layer.options;
          if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || "evenodd");
          }
          if (options.stroke && options.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
          }
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(e) {
          var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
        },
        _onMouseMove: function(e) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point = this._map.mouseEventToLayerPoint(e);
          this._handleMouseHover(e, point);
        },
        _handleMouseOut: function(e) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e, point) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
          this._mouseHoverThrottled = true;
          setTimeout(bind(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e, type) {
          this._map._fireDOMEvent(e, type || e.type, layers2);
        },
        _bringToFront: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order.prev = this._drawLast;
          this._drawLast.next = order;
          order.next = null;
          this._drawLast = order;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order.prev = null;
          order.next = this._drawFirst;
          this._drawFirst.prev = order;
          this._drawFirst = order;
          this._requestRedraw(layer);
        }
      });
      function canvas(options) {
        return Browser.canvas ? new Canvas(options) : null;
      }
      var vmlCreate = function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name) {
            return document.createElement("<lvml:" + name + ' class="lvml">');
          };
        } catch (e) {
        }
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
          container.stroked = !!options.stroke;
          container.filled = !!options.fill;
          if (options.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options.weight + "px";
            stroke.color = options.color;
            stroke.opacity = options.opacity;
            if (options.dashArray) {
              stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options.lineCap.replace("butt", "flat");
            stroke.joinstyle = options.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options.fillColor || options.color;
            fill.opacity = options.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path) {
          layer._path.v = path;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create = Browser.vml ? vmlCreate : svgCreate;
      var SVG = Renderer.extend({
        _initContainer: function() {
          this._container = create("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, size = b.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size)) {
            this._svgSize = size;
            container.setAttribute("width", size.x);
            container.setAttribute("height", size.y);
          }
          setPosition(container, b.min);
          container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
          this.fire("update");
        },
        // methods below are called by vector layers implementations
        _initPath: function(layer) {
          var path = layer._path = create("path");
          if (layer.options.className) {
            addClass(path, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path = layer._path, options = layer.options;
          if (!path) {
            return;
          }
          if (options.stroke) {
            path.setAttribute("stroke", options.color);
            path.setAttribute("stroke-opacity", options.opacity);
            path.setAttribute("stroke-width", options.weight);
            path.setAttribute("stroke-linecap", options.lineCap);
            path.setAttribute("stroke-linejoin", options.lineJoin);
            if (options.dashArray) {
              path.setAttribute("stroke-dasharray", options.dashArray);
            } else {
              path.removeAttribute("stroke-dasharray");
            }
            if (options.dashOffset) {
              path.setAttribute("stroke-dashoffset", options.dashOffset);
            } else {
              path.removeAttribute("stroke-dashoffset");
            }
          } else {
            path.setAttribute("stroke", "none");
          }
          if (options.fill) {
            path.setAttribute("fill", options.fillColor || options.color);
            path.setAttribute("fill-opacity", options.fillOpacity);
            path.setAttribute("fill-rule", options.fillRule || "evenodd");
          } else {
            path.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
          var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
          this._setPath(layer, d);
        },
        _setPath: function(layer, path) {
          layer._path.setAttribute("d", path);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser.vml) {
        SVG.include(vmlMixin);
      }
      function svg(options) {
        return Browser.svg || Browser.vml ? new SVG(options) : null;
      }
      Map.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name) {
          if (name === "overlayPane" || name === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name });
            this._paneRenderers[name] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options) {
          return this.options.preferCanvas && canvas(options) || svg(options);
        }
      });
      var Rectangle = Polygon.extend({
        initialize: function(latLngBounds, options) {
          Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(latLngBounds) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
        },
        _boundsToLatLngs: function(latLngBounds) {
          latLngBounds = toLatLngBounds(latLngBounds);
          return [
            latLngBounds.getSouthWest(),
            latLngBounds.getNorthWest(),
            latLngBounds.getNorthEast(),
            latLngBounds.getSouthEast()
          ];
        }
      });
      function rectangle(latLngBounds, options) {
        return new Rectangle(latLngBounds, options);
      }
      SVG.create = create;
      SVG.pointsToPath = pointsToPath;
      GeoJSON.geometryToLayer = geometryToLayer;
      GeoJSON.coordsToLatLng = coordsToLatLng;
      GeoJSON.coordsToLatLngs = coordsToLatLngs;
      GeoJSON.latLngToCoords = latLngToCoords;
      GeoJSON.latLngsToCoords = latLngsToCoords;
      GeoJSON.getFeature = getFeature;
      GeoJSON.asFeature = asFeature;
      Map.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map) {
          this._map = map;
          this._container = map._container;
          this._pane = map._panes.overlayPane;
          this._resetStateTimeout = 0;
          map.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e) {
          if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e);
          var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size.x + "px";
          this._box.style.height = size.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e) {
          if (e.which !== 1 && e.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
          var bounds = new LatLngBounds(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e) {
          if (e.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
          var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map.options.doubleClickZoom === "center") {
            map.setZoom(zoom2);
          } else {
            map.setZoomAround(e.containerPoint, zoom2);
          }
        }
      });
      Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: true,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: true,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: Infinity,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: false,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map = this._map;
            this._draggable = new Draggable(map._mapPane, map._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map.on("zoomend", this._onZoomEnd, this);
              map.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map = this._map;
          map._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map.fire("movestart").fire("dragstart");
          if (map.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e) {
          if (this._map.options.inertia) {
            var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time);
            this._prunePositions(time);
          }
          this._map.fire("move", e).fire("drag", e);
        },
        _prunePositions: function(time) {
          while (this._positions.length > 1 && time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold) {
          return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset.x < limit.min.x) {
            offset.x = this._viscousLimit(offset.x, limit.min.x);
          }
          if (offset.y < limit.min.y) {
            offset.y = this._viscousLimit(offset.y, limit.min.y);
          }
          if (offset.x > limit.max.x) {
            offset.x = this._viscousLimit(offset.x, limit.max.x);
          }
          if (offset.y > limit.max.y) {
            offset.y = this._viscousLimit(offset.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
          var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
          map.fire("dragend", e);
          if (noInertia) {
            map.fire("moveend");
          } else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset.x && !offset.y) {
              map.fire("moveend");
            } else {
              offset = map._limitOffset(offset, map.options.maxBounds);
              requestAnimFrame(function() {
                map.panBy(offset, {
                  duration: decelerationDuration,
                  easeLinearity: ease,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map.addInitHook("addHandler", "dragging", Drag);
      Map.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: true,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map) {
          this._map = map;
          this._setPanDelta(map.options.keyboardPanDelta);
          this._setZoomDelta(map.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys = this._panKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.left.length; i < len; i++) {
            keys[codes.left[i]] = [-1 * panDelta, 0];
          }
          for (i = 0, len = codes.right.length; i < len; i++) {
            keys[codes.right[i]] = [panDelta, 0];
          }
          for (i = 0, len = codes.down.length; i < len; i++) {
            keys[codes.down[i]] = [0, panDelta];
          }
          for (i = 0, len = codes.up.length; i < len; i++) {
            keys[codes.up[i]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;
          for (i = 0, len = codes.zoomIn.length; i < len; i++) {
            keys[codes.zoomIn[i]] = zoomDelta;
          }
          for (i = 0, len = codes.zoomOut.length; i < len; i++) {
            keys[codes.zoomOut[i]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          var key = e.keyCode, map = this._map, offset;
          if (key in this._panKeys) {
            if (!map._panAnim || !map._panAnim._inProgress) {
              offset = this._panKeys[key];
              if (e.shiftKey) {
                offset = toPoint(offset).multiplyBy(3);
              }
              if (map.options.maxBounds) {
                offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
              }
              if (map.options.worldCopyJump) {
                var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
                map.panTo(newLatLng);
              } else {
                map.panBy(offset);
              }
            }
          } else if (key in this._zoomKeys) {
            map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
            map.closePopup();
          } else {
            return;
          }
          stop(e);
        }
      });
      Map.addInitHook("addHandler", "keyboard", Keyboard);
      Map.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: true,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e) {
          var delta = getWheelDelta(e);
          var debounce = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e);
          if (!this._startTime) {
            this._startTime = +/* @__PURE__ */ new Date();
          }
          var left = Math.max(debounce - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind(this._performZoom, this), left);
          stop(e);
        },
        _performZoom: function() {
          var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
          map._stop();
          var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map.options.scrollWheelZoom === "center") {
            map.setZoom(zoom2 + delta);
          } else {
            map.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
          clearTimeout(this._holdTimeout);
          if (e.touches.length !== 1) {
            return;
          }
          var first = e.touches[0];
          this._startPos = this._newPos = new Point(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e) {
          var first = e.touches[0];
          this._newPos = new Point(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            // detail: 1,
            screenX: e.screenX,
            screenY: e.screenY,
            clientX: e.clientX,
            clientY: e.clientY
            // button: 2,
            // buttons: 2
          });
          simulatedEvent._simulated = true;
          e.target.dispatchEvent(simulatedEvent);
        }
      });
      Map.addInitHook("addHandler", "tapHold", TapHold);
      Map.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Browser.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
          var map = this._map;
          if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
          this._centerPoint = map.getSize()._divideBy(2);
          this._startLatLng = map.containerPointToLatLng(this._centerPoint);
          if (map.options.touchZoom !== "center") {
            this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p2);
          this._startZoom = map.getZoom();
          this._moved = false;
          this._zooming = true;
          map._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e);
        },
        _onTouchMove: function(e) {
          if (!e.touches || e.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
          this._zoom = map.getScaleZoom(scale2, this._startZoom);
          if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
            this._zoom = map._limitZoom(this._zoom);
          }
          if (map.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale2 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
            if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind(map._move, map, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map.BoxZoom = BoxZoom;
      Map.DoubleClickZoom = DoubleClickZoom;
      Map.Drag = Drag;
      Map.Keyboard = Keyboard;
      Map.ScrollWheelZoom = ScrollWheelZoom;
      Map.TapHold = TapHold;
      Map.TouchZoom = TouchZoom;
      exports2.Bounds = Bounds;
      exports2.Browser = Browser;
      exports2.CRS = CRS;
      exports2.Canvas = Canvas;
      exports2.Circle = Circle;
      exports2.CircleMarker = CircleMarker;
      exports2.Class = Class;
      exports2.Control = Control;
      exports2.DivIcon = DivIcon;
      exports2.DivOverlay = DivOverlay;
      exports2.DomEvent = DomEvent;
      exports2.DomUtil = DomUtil;
      exports2.Draggable = Draggable;
      exports2.Evented = Evented;
      exports2.FeatureGroup = FeatureGroup;
      exports2.GeoJSON = GeoJSON;
      exports2.GridLayer = GridLayer;
      exports2.Handler = Handler;
      exports2.Icon = Icon;
      exports2.ImageOverlay = ImageOverlay;
      exports2.LatLng = LatLng;
      exports2.LatLngBounds = LatLngBounds;
      exports2.Layer = Layer;
      exports2.LayerGroup = LayerGroup;
      exports2.LineUtil = LineUtil;
      exports2.Map = Map;
      exports2.Marker = Marker;
      exports2.Mixin = Mixin;
      exports2.Path = Path;
      exports2.Point = Point;
      exports2.PolyUtil = PolyUtil;
      exports2.Polygon = Polygon;
      exports2.Polyline = Polyline;
      exports2.Popup = Popup;
      exports2.PosAnimation = PosAnimation;
      exports2.Projection = index;
      exports2.Rectangle = Rectangle;
      exports2.Renderer = Renderer;
      exports2.SVG = SVG;
      exports2.SVGOverlay = SVGOverlay;
      exports2.TileLayer = TileLayer;
      exports2.Tooltip = Tooltip;
      exports2.Transformation = Transformation;
      exports2.Util = Util;
      exports2.VideoOverlay = VideoOverlay;
      exports2.bind = bind;
      exports2.bounds = toBounds;
      exports2.canvas = canvas;
      exports2.circle = circle;
      exports2.circleMarker = circleMarker;
      exports2.control = control;
      exports2.divIcon = divIcon;
      exports2.extend = extend;
      exports2.featureGroup = featureGroup;
      exports2.geoJSON = geoJSON;
      exports2.geoJson = geoJson;
      exports2.gridLayer = gridLayer;
      exports2.icon = icon;
      exports2.imageOverlay = imageOverlay;
      exports2.latLng = toLatLng;
      exports2.latLngBounds = toLatLngBounds;
      exports2.layerGroup = layerGroup;
      exports2.map = createMap;
      exports2.marker = marker;
      exports2.point = toPoint;
      exports2.polygon = polygon;
      exports2.polyline = polyline;
      exports2.popup = popup;
      exports2.rectangle = rectangle;
      exports2.setOptions = setOptions;
      exports2.stamp = stamp;
      exports2.svg = svg;
      exports2.svgOverlay = svgOverlay;
      exports2.tileLayer = tileLayer;
      exports2.tooltip = tooltip;
      exports2.transformation = toTransformation;
      exports2.version = version;
      exports2.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports2.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports2;
    });
  })(leafletSrc$1, leafletSrc$1.exports);
  return leafletSrc$1.exports;
}
var leafletSrcExports = requireLeafletSrc();
const L$1 = /* @__PURE__ */ getDefaultExportFromCjs(leafletSrcExports);
export {
  L$1 as L
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVhZmxldC1zcmMtREs3MlVSS2ouanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC1zcmMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuOS40LCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHBzOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAyMyBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5sZWFmbGV0ID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHZlcnNpb24gPSBcIjEuOS40XCI7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFV0aWxcclxuICAgKlxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG4gIFx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuICBcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG4gIFx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcbiAgXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuICBcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZGVzdDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG4gIHZhciBjcmVhdGUkMiA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuICBcdGZ1bmN0aW9uIEYoKSB7fVxyXG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG4gIFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEYoKTtcclxuICBcdH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuICAvLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG4gIFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICBcdGlmIChmbi5iaW5kKSB7XHJcbiAgXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbiAgLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuICB2YXIgbGFzdElkID0gMDtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbiAgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcbiAgXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuICBcdFx0b2JqWydfbGVhZmxldF9pZCddID0gKytsYXN0SWQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4gIC8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4gIC8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbiAgLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4gIC8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuICAvLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcbiAgXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuICBcdFx0bG9jayA9IGZhbHNlO1xyXG4gIFx0XHRpZiAoYXJncykge1xyXG4gIFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICBcdFx0XHRhcmdzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobG9jaykge1xyXG4gIFx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG4gIFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuICBcdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gIFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG4gIFx0XHRcdGxvY2sgPSB0cnVlO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiB3cmFwcGVyRm47XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbiAgLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4gIC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gIGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuICBcdHZhciBtYXggPSByYW5nZVsxXSxcclxuICBcdCAgICBtaW4gPSByYW5nZVswXSxcclxuICBcdCAgICBkID0gbWF4IC0gbWluO1xyXG4gIFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuICBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgd2l0aCBzcGVjaWZpZWQgYHByZWNpc2lvbmAuXHJcbiAgLy8gVGhlIGRlZmF1bHQgYHByZWNpc2lvbmAgdmFsdWUgaXMgNiBkZWNpbWFsIHBsYWNlcy5cclxuICAvLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuICBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBwcmVjaXNpb24pIHtcclxuICBcdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuICBcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2IDogcHJlY2lzaW9uKTtcclxuICBcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuICAvLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbiAgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuICBcdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuICBcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ29wdGlvbnMnKSkge1xyXG4gIFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlJDIob2JqLm9wdGlvbnMpIDoge307XHJcbiAgXHR9XHJcbiAgXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4gIC8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuICAvLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbiAgLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuICAvLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcbiAgXHR2YXIgcGFyYW1zID0gW107XHJcbiAgXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG4gIFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuICB9XHJcblxyXG4gIHZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4gIC8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4gIC8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbiAgLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbiAgLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbiAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcbiAgXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHZhbHVlO1xyXG4gIFx0fSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbiAgLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbiAgLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbiAgLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG4gIHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuICAvLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG4gIFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbiAgfVxyXG5cclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuICAvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbiAgZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcbiAgXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG4gIFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcbiAgXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gIFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuICB9XHJcblxyXG4gIHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbiAgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcbiAgXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuICAvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4gIC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuICAvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbiAgLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcbiAgXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcbiAgXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuICAvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuICBcdGlmIChpZCkge1xyXG4gIFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG4gIFx0fVxyXG4gIH1cblxuICB2YXIgVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBiaW5kOiBiaW5kLFxuICAgIGdldCBsYXN0SWQgKCkgeyByZXR1cm4gbGFzdElkOyB9LFxuICAgIHN0YW1wOiBzdGFtcCxcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgd3JhcE51bTogd3JhcE51bSxcbiAgICBmYWxzZUZuOiBmYWxzZUZuLFxuICAgIGZvcm1hdE51bTogZm9ybWF0TnVtLFxuICAgIHRyaW06IHRyaW0sXG4gICAgc3BsaXRXb3Jkczogc3BsaXRXb3JkcyxcbiAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuICAgIGdldFBhcmFtU3RyaW5nOiBnZXRQYXJhbVN0cmluZyxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIGVtcHR5SW1hZ2VVcmw6IGVtcHR5SW1hZ2VVcmwsXG4gICAgcmVxdWVzdEZuOiByZXF1ZXN0Rm4sXG4gICAgY2FuY2VsRm46IGNhbmNlbEZuLFxuICAgIHJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG4gICAgY2FuY2VsQW5pbUZyYW1lOiBjYW5jZWxBbmltRnJhbWVcbiAgfTtcblxuICAvLyBAY2xhc3MgQ2xhc3NcclxuICAvLyBAYWthIEwuQ2xhc3NcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuICAvLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbiAgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcbiAgXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIFx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcbiAgXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuICBcdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcyk7XHJcblxyXG4gIFx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG4gIFx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcbiAgXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcbiAgXHR2YXIgcHJvdG8gPSBjcmVhdGUkMihwYXJlbnRQcm90byk7XHJcbiAgXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuICBcdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuICBcdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG4gIFx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcbiAgXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuICBcdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuICBcdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcbiAgXHRcdGV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcbiAgXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuICBcdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgXHRleHRlbmQocHJvdG8sIHByb3BzKTtcclxuICBcdGRlbGV0ZSBwcm90by5zdGF0aWNzO1xyXG4gIFx0ZGVsZXRlIHByb3RvLmluY2x1ZGVzO1xyXG5cclxuICBcdC8vIG1lcmdlIG9wdGlvbnNcclxuICBcdGlmIChwcm90by5vcHRpb25zKSB7XHJcbiAgXHRcdHByb3RvLm9wdGlvbnMgPSBwYXJlbnRQcm90by5vcHRpb25zID8gY3JlYXRlJDIocGFyZW50UHJvdG8ub3B0aW9ucykgOiB7fTtcclxuICBcdFx0ZXh0ZW5kKHByb3RvLm9wdGlvbnMsIHByb3BzLm9wdGlvbnMpO1xyXG4gIFx0fVxyXG5cclxuICBcdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcbiAgXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG4gIFx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG4gIFx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiBOZXdDbGFzcztcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbiAgQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gIFx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcbiAgXHRpZiAocHJvcHMub3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLnByb3RvdHlwZS5vcHRpb25zID0gcGFyZW50T3B0aW9ucztcclxuICBcdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuICBDbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuICAvLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG4gIENsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuICBcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICBcdH07XHJcblxyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcbiAgXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG4gIFx0LyogZ2xvYmFsIEw6IHRydWUgKi9cclxuICBcdGlmICh0eXBlb2YgTCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0aW5jbHVkZXMgPSBpc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcbiAgXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuICBcdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBFdmVudGVkXHJcbiAgICogQGFrYSBMLkV2ZW50ZWRcclxuICAgKiBAaW5oZXJpdHMgQ2xhc3NcclxuICAgKlxyXG4gICAqIEEgc2V0IG9mIG1ldGhvZHMgc2hhcmVkIGJldHdlZW4gZXZlbnQtcG93ZXJlZCBjbGFzc2VzIChsaWtlIGBNYXBgIGFuZCBgTWFya2VyYCkuIEdlbmVyYWxseSwgZXZlbnRzIGFsbG93IHlvdSB0byBleGVjdXRlIHNvbWUgZnVuY3Rpb24gd2hlbiBzb21ldGhpbmcgaGFwcGVucyB3aXRoIGFuIG9iamVjdCAoZS5nLiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCwgY2F1c2luZyB0aGUgbWFwIHRvIGZpcmUgYCdjbGljaydgIGV2ZW50KS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICogXHRhbGVydChlLmxhdGxuZyk7XHJcbiAgICogfSApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gICAqXHJcbiAgICogbWFwLm9uKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBFdmVudHMgPSB7XHJcbiAgXHQvKiBAbWV0aG9kIG9uKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIFx0ICovXHJcbiAgXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG4gIFx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi4gSWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlbW92ZSBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGF0IHBhcnRpY3VsYXIgZXZlbnQgZnJvbSB0aGUgb2JqZWN0LiBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIGBvbmAsIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWUgY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvZmYoZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG4gIFx0ICovXHJcbiAgXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gIFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdFx0dmFyIHJlbW92ZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRpZiAocmVtb3ZlQWxsKSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSk7XHJcbiAgXHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuICBcdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBfb25jZSkge1xyXG4gIFx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBsaXN0ZW5lciB0eXBlOiAnICsgdHlwZW9mIGZuKTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuICBcdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuICBcdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcbiAgXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fTtcclxuICBcdFx0aWYgKF9vbmNlKSB7XHJcbiAgXHRcdFx0bmV3TGlzdGVuZXIub25jZSA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuICBcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG4gIFx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChuZXdMaXN0ZW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHR2YXIgbGlzdGVuZXJzLFxyXG4gIFx0XHQgICAgaSxcclxuICBcdFx0ICAgIGxlbjtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyAvLyByZW1vdmUgYWxsXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcbiAgXHRcdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3BcclxuICBcdFx0XHRcdC8vIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IGZhbHNlRm47XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuICBcdFx0dmFyIGluZGV4ID0gdGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdGlmIChpbmRleCAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHR2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaW5kZXhdO1xyXG4gIFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG4gIFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdFx0bGlzdGVuZXIuZm4gPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcbiAgXHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXJlKHR5cGU6IFN0cmluZywgZGF0YT86IE9iamVjdCwgcHJvcGFnYXRlPzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSBkYXRhXHJcbiAgXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG4gIFx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuICBcdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGV2ZW50ID0gZXh0ZW5kKHt9LCBkYXRhLCB7XHJcbiAgXHRcdFx0dHlwZTogdHlwZSxcclxuICBcdFx0XHR0YXJnZXQ6IHRoaXMsXHJcbiAgXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcbiAgXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcbiAgXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG4gIFx0XHRcdFx0XHQvLyBvZmYgb3ZlcndyaXRlcyBsLmZuLCBzbyB3ZSBuZWVkIHRvIGNvcHkgZm4gdG8gYSB2YXJcclxuICBcdFx0XHRcdFx0dmFyIGZuID0gbC5mbjtcclxuICBcdFx0XHRcdFx0aWYgKGwub25jZSkge1xyXG4gIFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIGZuLCBsLmN0eCk7XHJcbiAgXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdFx0Zm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcbiAgXHRcdFx0XHR9XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG4gIFx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcbiAgXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuICBcdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcbiAgXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCdcInN0cmluZ1wiIHR5cGUgYXJndW1lbnQgZXhwZWN0ZWQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbnB1dCBgZm5gIHZhbHVlLCBiZWNhdXNlIHdlIG5lZWQgdG8gdXNlIGl0IGZvciBwcm9wYWdhdGlvblxyXG4gIFx0XHR2YXIgX2ZuID0gZm47XHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRwcm9wYWdhdGUgPSAhIWZuO1xyXG4gIFx0XHRcdF9mbiA9IHVuZGVmaW5lZDtcclxuICBcdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xpc3RlbnModHlwZSwgX2ZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHRcdHJldHVybiB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG4gIFx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyByZXR1cm5zIHRoZSBpbmRleCAobnVtYmVyKSBvciBmYWxzZVxyXG4gIFx0X2xpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuICBcdFx0aWYgKCFmbikge1xyXG4gIFx0XHRcdHJldHVybiAhIWxpc3RlbmVycy5sZW5ndGg7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gaTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuICBcdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG4gIFx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG4gIFx0XHRcdFx0Ly8gaXQncyBhIGhvdCBwYXRoIHNpbmNlIExheWVyIHVzZXMgdGhlIG9uKG9iaikgc3ludGF4XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4sIHRydWUpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0LCB0cnVlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuICBcdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcbiAgXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcbiAgXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXSA9IG9iajtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuICBcdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW3N0YW1wKG9iaildO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG4gIFx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIGV4dGVuZCh7XHJcbiAgXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcbiAgXHRcdFx0XHRwcm9wYWdhdGVkRnJvbTogZS50YXJnZXRcclxuICBcdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuICAvLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG4gIEV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuICAvLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4gIC8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuICBFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbiAgLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG4gIEV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuICAvLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbiAgLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG4gIEV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbiAgLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbiAgLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG4gIEV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxuICB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIFBvaW50XHJcbiAgICogQGFrYSBMLlBvaW50XHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9pbnQgPSBMLnBvaW50KDIwMCwgMzAwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgYW5kIG9wdGlvbnMgdGhhdCBhY2NlcHQgYFBvaW50YCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAucGFuQnkoWzIwMCwgMzAwXSk7XHJcbiAgICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcbiAgXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcbiAgXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcbiAgXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcbiAgXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcbiAgXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG4gIH07XHJcblxyXG4gIFBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcbiAgXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuICBcdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcbiAgXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcbiAgXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dGhpcy54IC09IHBvaW50Lng7XHJcbiAgXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuICBcdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHR0aGlzLnggLz0gbnVtO1xyXG4gIFx0XHR0aGlzLnkgLz0gbnVtO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gIFx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgXHRcdHRoaXMueCAqPSBudW07XHJcbiAgXHRcdHRoaXMueSAqPSBudW07XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuICBcdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuICBcdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcbiAgXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG4gIFx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG4gIFx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG4gIFx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcbiAgXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcbiAgXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcbiAgXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuICBcdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRydW5jKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG4gIFx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IHRydW5jKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gIFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcbiAgXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcbiAgXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcbiAgXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG4gIFx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcbiAgXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4gIC8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbiAgLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4gIC8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbiAgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG4gIFx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG4gIFx0XHRyZXR1cm4geDtcclxuICBcdH1cclxuICBcdGlmIChpc0FycmF5KHgpKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoeFswXSwgeFsxXSk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuICBcdFx0cmV0dXJuIHg7XHJcbiAgXHR9XHJcbiAgXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoeC54LCB4LnkpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEJvdW5kc1xyXG4gICAqIEBha2EgTC5Cb3VuZHNcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIGluIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gICAqIHAyID0gTC5wb2ludCg0MCwgNjApLFxyXG4gICAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG4gIFx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuICBcdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBCb3VuZHMucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBtaW4yLCBtYXgyO1xyXG4gIFx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8ICd4JyBpbiBvYmopIHtcclxuICBcdFx0XHRtaW4yID0gbWF4MiA9IHRvUG9pbnQob2JqKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG4gIFx0XHRcdG1pbjIgPSBvYmoubWluO1xyXG4gIFx0XHRcdG1heDIgPSBvYmoubWF4O1xyXG5cclxuICBcdFx0XHRpZiAoIW1pbjIgfHwgIW1heDIpIHsgcmV0dXJuIHRoaXM7IH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuICBcdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gIFx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG4gIFx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gIFx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG4gIFx0XHRcdHRoaXMubWluID0gbWluMi5jbG9uZSgpO1xyXG4gIFx0XHRcdHRoaXMubWF4ID0gbWF4Mi5jbG9uZSgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihtaW4yLngsIHRoaXMubWluLngpO1xyXG4gIFx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChtYXgyLngsIHRoaXMubWF4LngpO1xyXG4gIFx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihtaW4yLnksIHRoaXMubWluLnkpO1xyXG4gIFx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChtYXgyLnksIHRoaXMubWF4LnkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludChcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcbiAgXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG4gIFx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBtaW4sIG1heDtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG4gIFx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcbiAgXHRcdFx0bWluID0gb2JqLm1pbjtcclxuICBcdFx0XHRtYXggPSBvYmoubWF4O1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG4gIFx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcbiAgXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuICBcdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG4gIFx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG4gIFx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcbiAgXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuICBcdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcbiAgXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG4gIFx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcbiAgXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcbiAgXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG4gIFx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG4gIFx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuICBcdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIG9yIHJldHJhY3RpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcmF0aW8gaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIE5lZ2F0aXZlIHZhbHVlcyB3aWxsIHJldHJhY3QgdGhlIGJvdW5kcy5cclxuICBcdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0bWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKG1pbi54IC0gbWF4LngpICogYnVmZmVyUmF0aW8sXHJcbiAgXHRcdHdpZHRoQnVmZmVyID0gTWF0aC5hYnMobWluLnkgLSBtYXgueSkgKiBidWZmZXJSYXRpbztcclxuXHJcblxyXG4gIFx0XHRyZXR1cm4gdG9Cb3VuZHMoXHJcbiAgXHRcdFx0dG9Qb2ludChtaW4ueCAtIGhlaWdodEJ1ZmZlciwgbWluLnkgLSB3aWR0aEJ1ZmZlciksXHJcbiAgXHRcdFx0dG9Qb2ludChtYXgueCArIGhlaWdodEJ1ZmZlciwgbWF4LnkgKyB3aWR0aEJ1ZmZlcikpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLm1pbi5lcXVhbHMoYm91bmRzLmdldFRvcExlZnQoKSkgJiZcclxuICBcdFx0XHR0aGlzLm1heC5lcXVhbHMoYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkpO1xyXG4gIFx0fSxcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4gIC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbiAgLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG4gIGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuICBcdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gICAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBjb3JuZXIxID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICAgKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICAgKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAuZml0Qm91bmRzKFtcclxuICAgKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gICAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICAgKiBdKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBMYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMikgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuICBcdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50XHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICBcdFx0XHRzdzIgPSBvYmo7XHJcbiAgXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuICBcdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcbiAgXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcbiAgXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuICBcdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcbiAgXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuICBcdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG4gIFx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcbiAgXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuICBcdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgbmV3IExhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuICBcdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuICBcdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuICBcdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Tm9ydGhFYXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcbiAgXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcbiAgXHRcdFx0b2JqID0gdG9MYXRMbmcob2JqKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuICBcdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcbiAgXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG4gIFx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG4gIFx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuICBcdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuICBcdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuICBcdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuICBcdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcbiAgXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcbiAgXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcbiAgXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuICBcdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcbiAgXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuICAvLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGJ5IGRlZmluaW5nIHR3byBkaWFnb25hbGx5IG9wcG9zaXRlIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG4gIGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuICBcdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdHJldHVybiBhO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoYSwgYik7XHJcbiAgfVxuXG4gIC8qIEBjbGFzcyBMYXRMbmdcclxuICAgKiBAYWthIEwuTGF0TG5nXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICAgKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICAgKiBtYXAucGFuVG8oe2xhdDogNTAsIGxuZzogMzB9KTtcclxuICAgKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYExhdExuZ2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gTGF0TG5nKGxhdCwgbG5nLCBhbHQpIHtcclxuICBcdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcbiAgXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcbiAgXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcbiAgXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG4gIFx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG4gIFx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuICBcdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBMYXRMbmcucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG4gIFx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG4gIFx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcbiAgXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbU3BoZXJpY2FsIExhdyBvZiBDb3NpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfbGF3X29mX2Nvc2luZXMpLlxyXG4gIFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXAoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuICBcdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIEVhcnRoLndyYXBMYXRMbmcodGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGluIHdoaWNoIGVhY2ggYm91bmRhcnkgaXMgYHNpemVJbk1ldGVycy8yYCBtZXRlcnMgYXBhcnQgZnJvbSB0aGUgYExhdExuZ2AuXHJcbiAgXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG4gIFx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuICBcdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiB0aGlzLmxhdCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG4gIFx0XHQgICAgICAgIFt0aGlzLmxhdCArIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyArIGxuZ0FjY3VyYWN5XSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZywgdGhpcy5hbHQpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmcobGF0aXR1ZGU6IE51bWJlciwgbG9uZ2l0dWRlOiBOdW1iZXIsIGFsdGl0dWRlPzogTnVtYmVyKTogTGF0TG5nXHJcbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4gIC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogT2JqZWN0KTogTGF0TG5nXHJcbiAgLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuICBmdW5jdGlvbiB0b0xhdExuZyhhLCBiLCBjKSB7XHJcbiAgXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdGlmIChpc0FycmF5KGEpICYmIHR5cGVvZiBhWzBdICE9PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuICBcdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuICBcdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuICBcdH1cclxuICBcdGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gbmV3IExhdExuZyhhLCBiLCBjKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gICAqIE9iamVjdCB0aGF0IGRlZmluZXMgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtcyBmb3IgcHJvamVjdGluZ1xyXG4gICAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAgICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICAgKiBbc3BhdGlhbCByZWZlcmVuY2Ugc3lzdGVtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGF0aWFsX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gICAqXHJcbiAgICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICAgKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAgICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhlIENSUyBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAgICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIHZhciBDUlMgPSB7XHJcbiAgXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG4gIFx0bGF0TG5nVG9Qb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG4gIFx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24uX3RyYW5zZm9ybShwcm9qZWN0ZWRQb2ludCwgc2NhbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuICBcdC8vIFRoZSBpbnZlcnNlIG9mIGBsYXRMbmdUb1BvaW50YC4gUHJvamVjdHMgcGl4ZWwgY29vcmRpbmF0ZXMgb24gYSBnaXZlblxyXG4gIFx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuICBcdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG4gIFx0Ly8gdGhpcyBDUlMgKGUuZy4gbWV0ZXJzIGZvciBFUFNHOjM4NTcsIGZvciBwYXNzaW5nIGl0IHRvIFdNUyBzZXJ2aWNlcykuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcbiAgXHQvLyBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBwYXJ0aWN1bGFyIHpvb20uIEZvciBleGFtcGxlLCBpdCByZXR1cm5zXHJcbiAgXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG4gIFx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHJldHVybiAyNTYgKiBNYXRoLnBvdygyLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuICBcdC8vIEludmVyc2Ugb2YgYHNjYWxlKClgLCByZXR1cm5zIHRoZSB6b29tIGxldmVsIGNvcnJlc3BvbmRpbmcgdG8gYSBzY2FsZVxyXG4gIFx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcbiAgXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICBcdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlIC8gMjU2KSAvIE1hdGguTE4yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIHByb2plY3Rpb24ncyBib3VuZHMgc2NhbGVkIGFuZCB0cmFuc2Zvcm1lZCBmb3IgdGhlIHByb3ZpZGVkIGB6b29tYC5cclxuICBcdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcbiAgXHRcdHZhciBiID0gdGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxcclxuICBcdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5tYXgsIHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG4gIFx0Ly8gU3RhbmRhcmQgY29kZSBuYW1lIG9mIHRoZSBDUlMgcGFzc2VkIGludG8gV01TIHNlcnZpY2VzIChlLmcuIGAnRVBTRzozODU3J2ApXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcbiAgXHQvLyBBbiBhcnJheSBvZiB0d28gbnVtYmVycyBkZWZpbmluZyB3aGV0aGVyIHRoZSBsb25naXR1ZGUgKGhvcml6b250YWwpIGNvb3JkaW5hdGVcclxuICBcdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcbiAgXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuICBcdC8vXHJcbiAgXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuICBcdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG4gIFx0Ly8gd3JhcExuZzogW21pbiwgbWF4XSxcclxuICBcdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG4gIFx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcbiAgXHQvLyBJZiB0cnVlLCB0aGUgY29vcmRpbmF0ZSBzcGFjZSB3aWxsIGJlIHVuYm91bmRlZCAoaW5maW5pdGUgaW4gYm90aCBheGVzKVxyXG4gIFx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGxhdCBhbmQgbG5nIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG4gIFx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgbG5nID0gdGhpcy53cmFwTG5nID8gd3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuICBcdFx0ICAgIGxhdCA9IHRoaXMud3JhcExhdCA/IHdyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcbiAgXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG4gIFx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdCb3VuZHNgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMud3JhcExhdExuZyhjZW50ZXIpLFxyXG4gIFx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuICBcdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG4gIFx0XHRpZiAobGF0U2hpZnQgPT09IDAgJiYgbG5nU2hpZnQgPT09IDApIHtcclxuICBcdFx0XHRyZXR1cm4gYm91bmRzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuICBcdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG4gIFx0XHQgICAgbmV3TmUgPSBuZXcgTGF0TG5nKG5lLmxhdCAtIGxhdFNoaWZ0LCBuZS5sbmcgLSBsbmdTaGlmdCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG4gIFx0fVxyXG4gIH07XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBDUlNcbiAgICogQGNycyBMLkNSUy5FYXJ0aFxuICAgKlxuICAgKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICAgKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICAgKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAgICogbWV0ZXJzLlxuICAgKi9cblxuICB2YXIgRWFydGggPSBleHRlbmQoe30sIENSUywge1xuICBcdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG4gIFx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcbiAgXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuICBcdC8vIHNlZSBodHRwczovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4gIFx0UjogNjM3MTAwMCxcblxuICBcdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cbiAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcbiAgXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcbiAgXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG4gIFx0XHQgICAgc2luRExhdCA9IE1hdGguc2luKChsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0KSAqIHJhZCAvIDIpLFxuICBcdFx0ICAgIHNpbkRMb24gPSBNYXRoLnNpbigobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG4gIFx0XHQgICAgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG4gIFx0XHRyZXR1cm4gdGhpcy5SICogYztcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gICAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICAgKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cclxuICB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG4gIFx0UjogZWFydGhSYWRpdXMsXHJcbiAgXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuICBcdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG4gIFx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG4gIFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG4gIFx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZCA9IGVhcnRoUmFkaXVzICogTWF0aC5QSTtcclxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcbiAgXHR9KSgpXHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gICAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICAgKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAgICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICAgKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gICAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAgICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG4gIFx0aWYgKGlzQXJyYXkoYSkpIHtcclxuICBcdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuICBcdFx0dGhpcy5fYSA9IGFbMF07XHJcbiAgXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG4gIFx0XHR0aGlzLl9jID0gYVsyXTtcclxuICBcdFx0dGhpcy5fZCA9IGFbM107XHJcbiAgXHRcdHJldHVybjtcclxuICBcdH1cclxuICBcdHRoaXMuX2EgPSBhO1xyXG4gIFx0dGhpcy5fYiA9IGI7XHJcbiAgXHR0aGlzLl9jID0gYztcclxuICBcdHRoaXMuX2QgPSBkO1xyXG4gIH1cclxuXHJcbiAgVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcbiAgXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuICBcdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuICBcdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG4gIFx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuICBcdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcbiAgXHRcdHJldHVybiBwb2ludDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuICBcdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuICBcdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcbiAgXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuICAvLyBFeHBlY3RzIGFuIGNvZWZmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4gIC8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG4gIGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG4gIFx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICAgKlxyXG4gICAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gICAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gICAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICAgKi9cclxuXHJcbiAgdmFyIEVQU0czODU3ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcbiAgXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuICBcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG4gIFx0fSgpKVxyXG4gIH0pO1xyXG5cclxuICB2YXIgRVBTRzkwMDkxMyA9IGV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuICBcdGNvZGU6ICdFUFNHOjkwMDkxMydcclxuICB9KTtcblxuICAvLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbiAgLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbiAgLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4gIC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbiAgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcbiAgXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xuICB9XG5cbiAgLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4gIC8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbiAgLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuICBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuICBcdHZhciBzdHIgPSAnJyxcbiAgXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuICBcdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuICBcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgXHRcdFx0cCA9IHBvaW50c1tqXTtcbiAgXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuICBcdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcbiAgXHR9XG5cbiAgXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuICBcdHJldHVybiBzdHIgfHwgJ00wIDAnO1xuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICAgKiBAYWthIEwuQnJvd3NlclxyXG4gICAqXHJcbiAgICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICAgKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG4gIHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxuICB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbiAgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuICAvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuICB2YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4gIC8vICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGFueSBicm93c2VyIHJ1bm5pbmcgb24gYW4gQW5kcm9pZCBwbGF0Zm9ybS5cclxuICB2YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxuICB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbiAgLyogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzk2MTI2NiBmb3IgZGV0YWlscyBvbiBkZXRlY3Rpbmcgc3RvY2sgQW5kcm9pZCAqL1xyXG4gIHZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciB0aGUgQW5kcm9pZCBzdG9jayBicm93c2VyIChpLmUuIG5vdCBDaHJvbWUpXHJcbiAgdmFyIGFuZHJvaWRTdG9jayA9IGFuZHJvaWQgJiYgdXNlckFnZW50Q29udGFpbnMoJ0dvb2dsZScpICYmIHdlYmtpdFZlciA8IDUzNyAmJiAhKCdBdWRpb05vZGUnIGluIHdpbmRvdyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG4gIHZhciBvcGVyYSA9ICEhd2luZG93Lm9wZXJhO1xyXG5cclxuICAvLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuICB2YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG4gIHZhciBnZWNrbyA9IHVzZXJBZ2VudENvbnRhaW5zKCdnZWNrbycpICYmICF3ZWJraXQgJiYgIW9wZXJhICYmICFpZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbiAgdmFyIHNhZmFyaSA9ICFjaHJvbWUgJiYgdXNlckFnZW50Q29udGFpbnMoJ3NhZmFyaScpO1xyXG5cclxuICB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuICB2YXIgb3BlcmExMiA9ICdPVHJhbnNpdGlvbicgaW4gc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbiAgdmFyIHdpbiA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdXaW4nKSA9PT0gMDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzO1xyXG5cclxuICAvLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBzdHlsZTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbiAgdmFyIG1zUG9pbnRlciA9ICF3aW5kb3cuUG9pbnRlckV2ZW50ICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbiAgdmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaE5hdGl2ZTogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcbiAgLy8gKipUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4qKiB0aGF0IHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBjb21wdXRlciB3aXRoXHJcbiAgLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4gIC8vIHRvdWNoIGV2ZW50cy5cclxuICB2YXIgdG91Y2hOYXRpdmUgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgISF3aW5kb3cuVG91Y2hFdmVudDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBlaXRoZXIgW3RvdWNoXSgjYnJvd3Nlci10b3VjaCkgb3IgW3BvaW50ZXJdKCNicm93c2VyLXBvaW50ZXIpIGV2ZW50cy5cclxuICAvLyBOb3RlOiBwb2ludGVyIGV2ZW50cyB3aWxsIGJlIHByZWZlcnJlZCAoaWYgYXZhaWxhYmxlKSwgYW5kIHByb2Nlc3NlZCBmb3IgYWxsIGB0b3VjaCpgIGxpc3RlbmVycy5cclxuICB2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHRvdWNoTmF0aXZlIHx8IHBvaW50ZXIpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuIG9yIG9uIGFueSBzY3JlZW4gd2hlbiBicm93c2VyJ3MgZGlzcGxheSB6b29tIGlzIG1vcmUgdGhhbiAxMDAlLlxyXG4gIHZhciByZXRpbmEgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAvIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpKSA+IDE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcGFzc2l2ZSBldmVudHMuXHJcbiAgdmFyIHBhc3NpdmVFdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gIFx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG4gIFx0dHJ5IHtcclxuICBcdFx0dmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xyXG4gIFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuICBcdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9KTtcclxuICBcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0JywgZmFsc2VGbiwgb3B0cyk7XHJcbiAgXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHQvLyBFcnJvcnMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIHNpbmNlIHRoaXMgaXMgb25seSBhIGJyb3dzZXIgc3VwcG9ydCB0ZXN0LlxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcclxuICB9KCkpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuICB2YXIgY2FudmFzJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gIFx0cmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcclxuICB9KCkpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cclxuICB2YXIgc3ZnJDEgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbiAgdmFyIGlubGluZVN2ZyA9ICEhc3ZnJDEgJiYgKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdGRpdi5pbm5lckhUTUwgPSAnPHN2Zy8+JztcclxuICBcdHJldHVybiAoZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQubmFtZXNwYWNlVVJJKSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcclxuICB9KSgpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLlxyXG4gIHZhciB2bWwgPSAhc3ZnJDEgJiYgKGZ1bmN0aW9uICgpIHtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XHJcblxyXG4gIFx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuICBcdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuICBcdFx0cmV0dXJuIHNoYXBlICYmICh0eXBlb2Ygc2hhcGUuYWRqID09PSAnb2JqZWN0Jyk7XHJcblxyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHR9XHJcbiAgfSgpKTtcclxuXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBNYWMgcGxhdGZvcm1cclxuICB2YXIgbWFjID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ01hYycpID09PSAwO1xyXG5cclxuICAvLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTGludXggcGxhdGZvcm1cclxuICB2YXIgbGludXggPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTGludXgnKSA9PT0gMDtcclxuXHJcbiAgZnVuY3Rpb24gdXNlckFnZW50Q29udGFpbnMoc3RyKSB7XHJcbiAgXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIHZhciBCcm93c2VyID0ge1xyXG4gIFx0aWU6IGllLFxyXG4gIFx0aWVsdDk6IGllbHQ5LFxyXG4gIFx0ZWRnZTogZWRnZSxcclxuICBcdHdlYmtpdDogd2Via2l0LFxyXG4gIFx0YW5kcm9pZDogYW5kcm9pZCxcclxuICBcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG4gIFx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXHJcbiAgXHRvcGVyYTogb3BlcmEsXHJcbiAgXHRjaHJvbWU6IGNocm9tZSxcclxuICBcdGdlY2tvOiBnZWNrbyxcclxuICBcdHNhZmFyaTogc2FmYXJpLFxyXG4gIFx0cGhhbnRvbTogcGhhbnRvbSxcclxuICBcdG9wZXJhMTI6IG9wZXJhMTIsXHJcbiAgXHR3aW46IHdpbixcclxuICBcdGllM2Q6IGllM2QsXHJcbiAgXHR3ZWJraXQzZDogd2Via2l0M2QsXHJcbiAgXHRnZWNrbzNkOiBnZWNrbzNkLFxyXG4gIFx0YW55M2Q6IGFueTNkLFxyXG4gIFx0bW9iaWxlOiBtb2JpbGUsXHJcbiAgXHRtb2JpbGVXZWJraXQ6IG1vYmlsZVdlYmtpdCxcclxuICBcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGVXZWJraXQzZCxcclxuICBcdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG4gIFx0cG9pbnRlcjogcG9pbnRlcixcclxuICBcdHRvdWNoOiB0b3VjaCxcclxuICBcdHRvdWNoTmF0aXZlOiB0b3VjaE5hdGl2ZSxcclxuICBcdG1vYmlsZU9wZXJhOiBtb2JpbGVPcGVyYSxcclxuICBcdG1vYmlsZUdlY2tvOiBtb2JpbGVHZWNrbyxcclxuICBcdHJldGluYTogcmV0aW5hLFxyXG4gIFx0cGFzc2l2ZUV2ZW50czogcGFzc2l2ZUV2ZW50cyxcclxuICBcdGNhbnZhczogY2FudmFzJDEsXHJcbiAgXHRzdmc6IHN2ZyQxLFxyXG4gIFx0dm1sOiB2bWwsXHJcbiAgXHRpbmxpbmVTdmc6IGlubGluZVN2ZyxcclxuICBcdG1hYzogbWFjLFxyXG4gIFx0bGludXg6IGxpbnV4XHJcbiAgfTtcblxuICAvKlxuICAgKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICAgKi9cblxuICB2YXIgUE9JTlRFUl9ET1dOID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJztcbiAgdmFyIFBPSU5URVJfTU9WRSA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyTW92ZScgICA6ICdwb2ludGVybW92ZSc7XG4gIHZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbiAgdmFyIFBPSU5URVJfQ0FOQ0VMID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJztcbiAgdmFyIHBFdmVudCA9IHtcbiAgXHR0b3VjaHN0YXJ0ICA6IFBPSU5URVJfRE9XTixcbiAgXHR0b3VjaG1vdmUgICA6IFBPSU5URVJfTU9WRSxcbiAgXHR0b3VjaGVuZCAgICA6IFBPSU5URVJfVVAsXG4gIFx0dG91Y2hjYW5jZWwgOiBQT0lOVEVSX0NBTkNFTFxuICB9O1xuICB2YXIgaGFuZGxlID0ge1xuICBcdHRvdWNoc3RhcnQgIDogX29uUG9pbnRlclN0YXJ0LFxuICBcdHRvdWNobW92ZSAgIDogX2hhbmRsZVBvaW50ZXIsXG4gIFx0dG91Y2hlbmQgICAgOiBfaGFuZGxlUG9pbnRlcixcbiAgXHR0b3VjaGNhbmNlbCA6IF9oYW5kbGVQb2ludGVyXG4gIH07XG4gIHZhciBfcG9pbnRlcnMgPSB7fTtcbiAgdmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuICAvLyBQcm92aWRlcyBhIHRvdWNoIGV2ZW50cyB3cmFwcGVyIGZvciAobXMpcG9pbnRlciBldmVudHMuXG4gIC8vIHJlZiBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG4gIGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcbiAgXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gIFx0XHRfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCk7XG4gIFx0fVxuICBcdGlmICghaGFuZGxlW3R5cGVdKSB7XG4gIFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcbiAgXHRcdHJldHVybiBmYWxzZUZuO1xuICBcdH1cbiAgXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG4gIFx0cmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG4gIFx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG4gIFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuICBcdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG4gIFx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcbiAgXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKSB7XG4gIFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG4gIFx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG4gIFx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG4gIFx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKSB7XG4gIFx0aWYgKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSB7IHJldHVybjsgfVxuXG4gIFx0ZS50b3VjaGVzID0gW107XG4gIFx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcbiAgXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG4gIFx0fVxuICBcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cbiAgXHRoYW5kbGVyKGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uUG9pbnRlclN0YXJ0KGhhbmRsZXIsIGUpIHtcbiAgXHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcbiAgXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9XG4gIFx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG4gIH1cblxuICAvKlxyXG4gICAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICAgKlxyXG4gICAqIE5vdGU6IGN1cnJlbnRseSBtb3N0IGJyb3dzZXJzIGZpcmUgbmF0aXZlIGRibGNsaWNrLCB3aXRoIG9ubHkgYSBmZXcgZXhjZXB0aW9uc1xyXG4gICAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBtYWtlRGJsY2xpY2soZXZlbnQpIHtcclxuICBcdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuICBcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seVxyXG4gIFx0dmFyIG5ld0V2ZW50ID0ge30sXHJcbiAgXHQgICAgcHJvcCwgaTtcclxuICBcdGZvciAoaSBpbiBldmVudCkge1xyXG4gIFx0XHRwcm9wID0gZXZlbnRbaV07XHJcbiAgXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuICBcdH1cclxuICBcdGV2ZW50ID0gbmV3RXZlbnQ7XHJcbiAgXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuICBcdG5ld0V2ZW50LmRldGFpbCA9IDI7XHJcbiAgXHRuZXdFdmVudC5pc1RydXN0ZWQgPSBmYWxzZTtcclxuICBcdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuICBcdHJldHVybiBuZXdFdmVudDtcclxuICB9XHJcblxyXG4gIHZhciBkZWxheSA9IDIwMDtcclxuICBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpIHtcclxuICBcdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIpO1xyXG5cclxuICBcdC8vIE9uIHNvbWUgcGxhdGZvcm1zIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSBuYXRpdmUgZGJsY2xpY2tzIGZvciB0b3VjaCBldmVudHMuXHJcbiAgXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuICBcdC8vIFNvIGhlcmUgd2UgcmVseSBvbiB0aGF0IGZhY3QgdG8gYXZvaWQgZXhjZXNzaXZlICdkYmxjbGljaycgc2ltdWxhdGlvbiB3aGVuIG5vdCBuZWVkZWQuXHJcbiAgXHR2YXIgbGFzdCA9IDAsXHJcbiAgXHQgICAgZGV0YWlsO1xyXG4gIFx0ZnVuY3Rpb24gc2ltRGJsY2xpY2soZSkge1xyXG4gIFx0XHRpZiAoZS5kZXRhaWwgIT09IDEpIHtcclxuICBcdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcbiAgXHRcdFx0KGUuc291cmNlQ2FwYWJpbGl0aWVzICYmICFlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSkge1xyXG5cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIFdoZW4gY2xpY2tpbmcgb24gYW4gPGlucHV0PiwgdGhlIGJyb3dzZXIgZ2VuZXJhdGVzIGEgY2xpY2sgb24gaXRzXHJcbiAgXHRcdC8vIDxsYWJlbD4gKGFuZCB2aWNlIHZlcnNhKSB0cmlnZ2VyaW5nIHR3byBjbGlja3MgaW4gcXVpY2sgc3VjY2Vzc2lvbi5cclxuICBcdFx0Ly8gVGhpcyBpZ25vcmVzIGNsaWNrcyBvbiBlbGVtZW50cyB3aGljaCBhcmUgYSBsYWJlbCB3aXRoIGEgJ2ZvcidcclxuICBcdFx0Ly8gYXR0cmlidXRlIChvciBjaGlsZHJlbiBvZiBzdWNoIGEgbGFiZWwpLCBidXQgbm90IGNoaWxkcmVuIG9mXHJcbiAgXHRcdC8vIGEgPGlucHV0Pi5cclxuICBcdFx0dmFyIHBhdGggPSBnZXRQcm9wYWdhdGlvblBhdGgoZSk7XHJcbiAgXHRcdGlmIChwYXRoLnNvbWUoZnVuY3Rpb24gKGVsKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGVsIGluc3RhbmNlb2YgSFRNTExhYmVsRWxlbWVudCAmJiBlbC5hdHRyaWJ1dGVzLmZvcjtcclxuICBcdFx0fSkgJiZcclxuICBcdFx0XHQhcGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIChcclxuICBcdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8XHJcbiAgXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnRcclxuICBcdFx0XHRcdCk7XHJcbiAgXHRcdFx0fSlcclxuICBcdFx0KSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuICBcdFx0aWYgKG5vdyAtIGxhc3QgPD0gZGVsYXkpIHtcclxuICBcdFx0XHRkZXRhaWwrKztcclxuICBcdFx0XHRpZiAoZGV0YWlsID09PSAyKSB7XHJcbiAgXHRcdFx0XHRoYW5kbGVyKG1ha2VEYmxjbGljayhlKSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGRldGFpbCA9IDE7XHJcbiAgXHRcdH1cclxuICBcdFx0bGFzdCA9IG5vdztcclxuICBcdH1cclxuXHJcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaW1EYmxjbGljayk7XHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0ZGJsY2xpY2s6IGhhbmRsZXIsXHJcbiAgXHRcdHNpbURibGNsaWNrOiBzaW1EYmxjbGlja1xyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcnMpIHtcclxuICBcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXJzLmRibGNsaWNrKTtcclxuICBcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXJzLnNpbURibGNsaWNrKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICAgKlxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICAgKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKlxyXG4gICAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICAgKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAgICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbiAgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG4gIFx0Wyd0cmFuc2Zvcm0nLCAnd2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuICAvLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbiAgLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG4gIHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcbiAgXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG4gIHZhciBUUkFOU0lUSU9OX0VORCA9XHJcbiAgXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbiAgLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuICBmdW5jdGlvbiBnZXQoaWQpIHtcclxuICBcdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbiAgLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuICAvLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbiAgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcbiAgXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcbiAgXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG4gIFx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcbiAgXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuICBmdW5jdGlvbiBjcmVhdGUkMSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG4gIFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICBcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcbiAgXHRpZiAoY29udGFpbmVyKSB7XHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZWw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuICBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCkge1xyXG4gIFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbiAgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuICBcdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcbiAgXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbiAgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcbiAgXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbiAgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcbiAgXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG4gIFx0fVxyXG4gIFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuICBcdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHR2YXIgY2xhc3NlcyA9IHNwbGl0V29yZHMobmFtZSk7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcbiAgXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRzZXRDbGFzcyhlbCwgdHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbiAgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcbiAgXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuICAvLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbiAgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuICBcdC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWR0VsZW1lbnRJbnN0YW5jZSBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nRWxlbWVudCBpbnN0ZWFkXHJcbiAgXHQvLyAoUmVxdWlyZWQgZm9yIGxpbmtlZCBTVkcgZWxlbWVudHMgaW4gSUUxMS4pXHJcbiAgXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuICBcdFx0ZWwgPSBlbC5jb3JyZXNwb25kaW5nRWxlbWVudDtcclxuICBcdH1cclxuICBcdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuICAvLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuICAvLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbiAgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuICBcdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuICBcdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG4gIFx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG4gIFx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG4gIFx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG4gIFx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuICBcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG4gIFx0dHJ5IHtcclxuICBcdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG4gIFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuICBcdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuICBcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG4gIFx0fVxyXG5cclxuICBcdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG4gIFx0aWYgKGZpbHRlcikge1xyXG4gIFx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuICBcdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbiAgLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4gIC8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbiAgLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbiAgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuICBcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG4gIFx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4gIC8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbiAgLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4gIC8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG4gIGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG4gIFx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG4gIFx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcbiAgXHRcdChCcm93c2VyLmllM2QgP1xyXG4gIFx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuICBcdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuICBcdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbiAgLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuICAvLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4gIC8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuICBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcbiAgXHQvKmVzbGludC1kaXNhYmxlICovXHJcbiAgXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuICBcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbiAgXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG4gIFx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuICBcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcbiAgXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuICBcdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG4gIFx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4gIC8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbiAgLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuICAvLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbiAgLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbiAgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG4gIHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG4gIHZhciBfdXNlclNlbGVjdDtcclxuICBpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcbiAgXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0b24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHR9O1xyXG4gIFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0b2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0fTtcclxuICB9IGVsc2Uge1xyXG4gIFx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG4gIFx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcbiAgXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gIFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuICBcdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcbiAgXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuICBcdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICBcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG4gIFx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4gIC8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuICAvLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuICBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG4gIFx0b24od2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbiAgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG4gIFx0b2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICB9XHJcblxyXG4gIHZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbiAgLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4gIC8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbiAgLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4gIC8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuICBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcbiAgXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuICBcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICBcdH1cclxuICBcdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuICBcdHJlc3RvcmVPdXRsaW5lKCk7XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlO1xyXG4gIFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XHJcbiAgXHRvbih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG4gIGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG4gIFx0aWYgKCFfb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gX291dGxpbmVTdHlsZTtcclxuICBcdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICBcdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcbiAgXHRvZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWw6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB3aGljaCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBpcyBub3QgbnVsbC5cclxuICBmdW5jdGlvbiBnZXRTaXplZFBhcmVudE5vZGUoZWxlbWVudCkge1xyXG4gIFx0ZG8ge1xyXG4gIFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIFx0fSB3aGlsZSAoKCFlbGVtZW50Lm9mZnNldFdpZHRoIHx8ICFlbGVtZW50Lm9mZnNldEhlaWdodCkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSk7XHJcbiAgXHRyZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTY2FsZShlbDogSFRNTEVsZW1lbnQpOiBPYmplY3RcclxuICAvLyBDb21wdXRlcyB0aGUgQ1NTIHNjYWxlIGN1cnJlbnRseSBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4gIC8vIGFuZCBgYm91bmRpbmdDbGllbnRSZWN0YCBhcyB0aGUgcmVzdWx0IG9mIFtgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QpLlxyXG4gIGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuICBcdHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gUmVhZC1vbmx5IGluIG9sZCBicm93c2Vycy5cclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG4gIFx0XHR5OiByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEsXHJcbiAgXHRcdGJvdW5kaW5nQ2xpZW50UmVjdDogcmVjdFxyXG4gIFx0fTtcclxuICB9XG5cbiAgdmFyIERvbVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFRSQU5TRk9STTogVFJBTlNGT1JNLFxuICAgIFRSQU5TSVRJT046IFRSQU5TSVRJT04sXG4gICAgVFJBTlNJVElPTl9FTkQ6IFRSQU5TSVRJT05fRU5ELFxuICAgIGdldDogZ2V0LFxuICAgIGdldFN0eWxlOiBnZXRTdHlsZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICB0b0Zyb250OiB0b0Zyb250LFxuICAgIHRvQmFjazogdG9CYWNrLFxuICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgIHNldENsYXNzOiBzZXRDbGFzcyxcbiAgICBnZXRDbGFzczogZ2V0Q2xhc3MsXG4gICAgc2V0T3BhY2l0eTogc2V0T3BhY2l0eSxcbiAgICB0ZXN0UHJvcDogdGVzdFByb3AsXG4gICAgc2V0VHJhbnNmb3JtOiBzZXRUcmFuc2Zvcm0sXG4gICAgc2V0UG9zaXRpb246IHNldFBvc2l0aW9uLFxuICAgIGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvbixcbiAgICBnZXQgZGlzYWJsZVRleHRTZWxlY3Rpb24gKCkgeyByZXR1cm4gZGlzYWJsZVRleHRTZWxlY3Rpb247IH0sXG4gICAgZ2V0IGVuYWJsZVRleHRTZWxlY3Rpb24gKCkgeyByZXR1cm4gZW5hYmxlVGV4dFNlbGVjdGlvbjsgfSxcbiAgICBkaXNhYmxlSW1hZ2VEcmFnOiBkaXNhYmxlSW1hZ2VEcmFnLFxuICAgIGVuYWJsZUltYWdlRHJhZzogZW5hYmxlSW1hZ2VEcmFnLFxuICAgIHByZXZlbnRPdXRsaW5lOiBwcmV2ZW50T3V0bGluZSxcbiAgICByZXN0b3JlT3V0bGluZTogcmVzdG9yZU91dGxpbmUsXG4gICAgZ2V0U2l6ZWRQYXJlbnROb2RlOiBnZXRTaXplZFBhcmVudE5vZGUsXG4gICAgZ2V0U2NhbGU6IGdldFNjYWxlXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICovXHJcblxyXG4gIC8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4gIC8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbiAgLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuICAvLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbiAgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0fVxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuICAvLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbiAgLy8gY29udGV4dCB0byBgb2ZmYCBpbiBvcmRlciB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nKTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIG9mIGdpdmVuIHR5cGVzLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBmcm9tIGdpdmVuIEhUTUxFbGVtZW50XHJcbiAgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICBcdFx0YmF0Y2hSZW1vdmUob2JqKTtcclxuICBcdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cclxuICBcdH0gZWxzZSBpZiAodHlwZXMgJiYgdHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0fVxyXG5cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gIFx0XHRcdGJhdGNoUmVtb3ZlKG9iaiwgZnVuY3Rpb24gKHR5cGUpIHtcclxuICBcdFx0XHRcdHJldHVybiBpbmRleE9mKHR5cGVzLCB0eXBlKSAhPT0gLTE7XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmF0Y2hSZW1vdmUob2JqLCBmaWx0ZXJGbikge1xyXG4gIFx0Zm9yICh2YXIgaWQgaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuICBcdFx0dmFyIHR5cGUgPSBpZC5zcGxpdCgvXFxkLylbMF07XHJcbiAgXHRcdGlmICghZmlsdGVyRm4gfHwgZmlsdGVyRm4odHlwZSkpIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCBudWxsLCBudWxsLCBpZCk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9XHJcblxyXG4gIHZhciBtb3VzZVN1YnN0ID0ge1xyXG4gIFx0bW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXHJcbiAgXHRtb3VzZWxlYXZlOiAnbW91c2VvdXQnLFxyXG4gIFx0d2hlZWw6ICEoJ29ud2hlZWwnIGluIHdpbmRvdykgJiYgJ21vdXNld2hlZWwnXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdHZhciBpZCA9IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuICBcdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcbiAgXHR9O1xyXG5cclxuICBcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuICBcdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcbiAgXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuICBcdFx0aGFuZGxlciA9IGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuICBcdFx0aGFuZGxlciA9IGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd3aGVlbCcgfHwgIHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xyXG4gIFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG4gIFx0XHRcdFx0aWYgKGlzRXh0ZXJuYWxUYXJnZXQob2JqLCBlKSkge1xyXG4gIFx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fTtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIG9yaWdpbmFsSGFuZGxlciwgZmFsc2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuICBcdH1cclxuXHJcbiAgXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG4gIFx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0LCBpZCkge1xyXG4gIFx0aWQgPSBpZCB8fCB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuICBcdHZhciBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuICBcdGlmICghaGFuZGxlcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdGlmICghQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcbiAgXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykpIHtcclxuICBcdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcbiAgXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcbiAgXHR9XHJcblxyXG4gIFx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4gIC8vIGBgYGpzXHJcbiAgLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gIC8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4gIC8vIH0pO1xyXG4gIC8vIGBgYFxyXG4gIGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG4gIFx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG4gIFx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbiAgLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnd2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcbiAgXHRhZGRPbmUoZWwsICd3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbiAgLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkYmxjbGljaydgLCBgJ2NvbnRleHRtZW51J2AsXHJcbiAgLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcbiAgXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrIGNvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdGVsWydfbGVhZmxldF9kaXNhYmxlX2NsaWNrJ10gPSB0cnVlO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuICAvLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbiAgLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuICAvLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcbiAgXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gIFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBEb2VzIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgZnVuY3Rpb24gc3RvcChlKSB7XHJcbiAgXHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldjogRE9NRXZlbnQpOiBBcnJheVxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtgRXZlbnQuY29tcG9zZWRQYXRoKClgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnQvY29tcG9zZWRQYXRoKS5cclxuICAvLyBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGBIVE1MRWxlbWVudGBzIHRoYXQgdGhlIGdpdmVuIERPTSBldmVudFxyXG4gIC8vIHNob3VsZCBwcm9wYWdhdGUgdG8gKGlmIG5vdCBzdG9wcGVkKS5cclxuICBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXYpIHtcclxuICBcdGlmIChldi5jb21wb3NlZFBhdGgpIHtcclxuICBcdFx0cmV0dXJuIGV2LmNvbXBvc2VkUGF0aCgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBwYXRoID0gW107XHJcbiAgXHR2YXIgZWwgPSBldi50YXJnZXQ7XHJcblxyXG4gIFx0d2hpbGUgKGVsKSB7XHJcbiAgXHRcdHBhdGgucHVzaChlbCk7XHJcbiAgXHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuICBcdH1cclxuICBcdHJldHVybiBwYXRoO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGV2OiBET01FdmVudCwgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4gIC8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4gIC8vIGBjb250YWluZXJgIChib3JkZXIgZXhjbHVkZWQpIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuICBcdGlmICghY29udGFpbmVyKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzY2FsZSA9IGdldFNjYWxlKGNvbnRhaW5lciksXHJcbiAgXHQgICAgb2Zmc2V0ID0gc2NhbGUuYm91bmRpbmdDbGllbnRSZWN0OyAvLyBsZWZ0IGFuZCB0b3AgIHZhbHVlcyBhcmUgaW4gcGFnZSBzY2FsZSAobGlrZSB0aGUgZXZlbnQgY2xpZW50WC9ZKVxyXG5cclxuICBcdHJldHVybiBuZXcgUG9pbnQoXHJcbiAgXHRcdC8vIG9mZnNldC5sZWZ0L3RvcCB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgY2xpZW50WC9ZKSxcclxuICBcdFx0Ly8gd2hlcmVhcyBjbGllbnRMZWZ0L1RvcCAoYm9yZGVyIHdpZHRoKSB2YWx1ZXMgYXJlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgKGJlZm9yZSBDU1Mgc2NhbGUgYXBwbGllcykuXHJcbiAgXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcbiAgXHRcdChlLmNsaWVudFkgLSBvZmZzZXQudG9wKSAvIHNjYWxlLnkgLSBjb250YWluZXIuY2xpZW50VG9wXHJcbiAgXHQpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vICBleGNlcHQgLCBTYWZhcmkgYW5kXHJcbiAgLy8gV2UgbmVlZCBkb3VibGUgdGhlIHNjcm9sbCBwaXhlbHMgKHNlZSAjNzQwMyBhbmQgIzQ1MzgpIGZvciBhbGwgQnJvd3NlcnNcclxuICAvLyBleGNlcHQgT1NYIChNYWMpIC0+IDN4LCBDaHJvbWUgcnVubmluZyBvbiBMaW51eCAxeFxyXG5cclxuICB2YXIgd2hlZWxQeEZhY3RvciA9XHJcbiAgXHQoQnJvd3Nlci5saW51eCAmJiBCcm93c2VyLmNocm9tZSkgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcbiAgXHRCcm93c2VyLm1hYyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogMyA6XHJcbiAgXHR3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDAgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG4gIC8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4gIC8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4gIC8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4gIC8vIEV2ZW50cyBmcm9tIHBvaW50aW5nIGRldmljZXMgd2l0aG91dCBwcmVjaXNlIHNjcm9sbGluZyBhcmUgbWFwcGVkIHRvXHJcbiAgLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuICBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGUpIHtcclxuICBcdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDEpID8gLWUuZGVsdGFZICogMjAgOiAvLyBMaW5lc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG4gIFx0ICAgICAgIGUud2hlZWxEZWx0YSA/IChlLndoZWVsRGVsdGFZIHx8IGUud2hlZWxEZWx0YSkgLyAyIDogLy8gTGVnYWN5IElFIHBpeGVsc1xyXG4gIFx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuICBcdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcbiAgXHQgICAgICAgMDtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG4gIGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcbiAgXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcbiAgXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgXHR0cnkge1xyXG4gIFx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcbiAgXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0fSBjYXRjaCAoZXJyKSB7XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH1cclxuICBcdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG4gIH1cblxuICB2YXIgRG9tRXZlbnQgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgICBzdG9wUHJvcGFnYXRpb246IHN0b3BQcm9wYWdhdGlvbixcbiAgICBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246IGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbixcbiAgICBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjogZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24sXG4gICAgcHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuICAgIHN0b3A6IHN0b3AsXG4gICAgZ2V0UHJvcGFnYXRpb25QYXRoOiBnZXRQcm9wYWdhdGlvblBhdGgsXG4gICAgZ2V0TW91c2VQb3NpdGlvbjogZ2V0TW91c2VQb3NpdGlvbixcbiAgICBnZXRXaGVlbERlbHRhOiBnZXRXaGVlbERlbHRhLFxuICAgIGlzRXh0ZXJuYWxUYXJnZXQ6IGlzRXh0ZXJuYWxUYXJnZXQsXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIHJlbW92ZUxpc3RlbmVyOiBvZmZcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9zQW5pbWF0aW9uXG4gICAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBwYW5uaW5nIGFuaW1hdGlvbnMsIHV0aWxpemluZyBDU1MzIFRyYW5zaXRpb25zIGZvciBtb2Rlcm4gYnJvd3NlcnMgYW5kIGEgdGltZXIgZmFsbGJhY2sgZm9yIElFNi05LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlQb3NpdGlvbk1hcmtlciA9IEwubWFya2VyKFs0OC44NjQ3MTYsIDIuMjk0Njk0XSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogbXlQb3NpdGlvbk1hcmtlci5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgKiBcdHZhciBwb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KG15UG9zaXRpb25NYXJrZXIuZ2V0TGF0TG5nKCkpO1xuICAgKiBcdHBvcy55IC09IDI1O1xuICAgKiBcdHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICAgKlxuICAgKiBcdGZ4Lm9uY2UoJ2VuZCcsZnVuY3Rpb24oKSB7XG4gICAqIFx0XHRwb3MueSArPSAyNTtcbiAgICogXHRcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuOCk7XG4gICAqIFx0fSk7XG4gICAqXG4gICAqIFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC4zKTtcbiAgICogfSk7XG4gICAqXG4gICAqIGBgYFxuICAgKlxuICAgKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICAgKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKi9cblxuICB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG4gIFx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcbiAgXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG4gIFx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG4gIFx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHBzOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuICBcdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuICBcdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG4gIFx0XHR0aGlzLnN0b3AoKTtcblxuICBcdFx0dGhpcy5fZWwgPSBlbDtcbiAgXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuICBcdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuICBcdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKGVsKTtcbiAgXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICBcdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG4gIFx0XHR0aGlzLl9hbmltYXRlKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc3RvcCgpXG4gIFx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fc3RlcCh0cnVlKTtcbiAgXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBhbmltYXRpb24gbG9vcFxuICBcdFx0dGhpcy5fYW5pbUlkID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcbiAgXHRcdHRoaXMuX3N0ZXAoKTtcbiAgXHR9LFxuXG4gIFx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuICBcdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuICBcdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG4gIFx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG4gIFx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuICBcdFx0aWYgKHJvdW5kKSB7XG4gIFx0XHRcdHBvcy5fcm91bmQoKTtcbiAgXHRcdH1cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG4gIFx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuICBcdH0sXG5cbiAgXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG4gIFx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuICBcdH0sXG5cbiAgXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXBcclxuICAgKiBAYWthIEwuTWFwXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gICAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAgICogXHR6b29tOiAxM1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuICBcdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG4gIFx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuICBcdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICBcdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuICBcdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG4gIFx0XHRsYXllcnM6IFtdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuICBcdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG4gIFx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG4gIFx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuICBcdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG4gIFx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcbiAgXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG4gIFx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG4gIFx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuICBcdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG4gIFx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG4gIFx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG4gIFx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG4gIFx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG4gIFx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG4gIFx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcbiAgXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG4gIFx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcbiAgXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHR6b29tU25hcDogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuICBcdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuICBcdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuICBcdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG4gIFx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG4gIFx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuICBcdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcbiAgXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuICBcdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG4gIFx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG4gIFx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuICBcdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuICBcdFx0XHRvbih0aGlzLl9wcm94eSwgVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcbiAgXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuICBcdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG4gIFx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnBhbiA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuICBcdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG4gIFx0XHRcdGlmIChtb3ZlZCkge1xyXG4gIFx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcbiAgXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMucGFuICYmIG9wdGlvbnMucGFuLm5vTW92ZVN0YXJ0KTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuICBcdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG4gIFx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuICBcdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuICBcdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG4gIFx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuICBcdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuICBcdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuICBcdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG4gIFx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuICBcdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcbiAgXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG4gIFx0XHRcdHJldHVybiB7XHJcbiAgXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0XHRcdHpvb206IHpvb21cclxuICBcdFx0XHR9O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuICBcdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuICBcdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb21cclxuICBcdFx0fTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcbiAgXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcbiAgXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuICBcdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcbiAgXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuICBcdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG4gIFx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuICBcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcbiAgXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuICBcdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuICBcdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuICBcdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG4gIFx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcclxuICBcdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuICBcdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcbiAgXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG4gIFx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuICBcdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuICBcdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG4gIFx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG4gIFx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcbiAgXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuICBcdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG4gIFx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuICBcdFx0ICAgIHJobyA9IDEuNDIsXHJcbiAgXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gcihpKSB7XHJcbiAgXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuICBcdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuICBcdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG4gIFx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuICBcdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcbiAgXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuICBcdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG4gIFx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG4gIFx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcbiAgXHRcdFx0cmV0dXJuIGxvZztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG4gIFx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcbiAgXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG4gIFx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuICBcdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcbiAgXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcbiAgXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcbiAgXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcbiAgXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG4gIFx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG4gIFx0XHRcdGlmICh0IDw9IDEpIHtcclxuICBcdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcbiAgXHRcdFx0XHR0aGlzLl9tb3ZlKFxyXG4gIFx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG4gIFx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcbiAgXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xyXG5cclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhpc1xyXG4gIFx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxyXG4gIFx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG4gIFx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxyXG4gIFx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG4gIFx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuICBcdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMubGlzdGVucygnbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcykpIHtcclxuICBcdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBsb3dlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWluWm9vbV0oI21hcC1taW56b29tKSBvcHRpb24pLlxyXG4gIFx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuICBcdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIGF2YWlsYWJsZSB6b29tIGxldmVscyAoc2VlIHRoZSBbbWF4Wm9vbV0oI21hcC1tYXh6b29tKSBvcHRpb24pLlxyXG4gIFx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuICBcdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuICBcdHBhbkluc2lkZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG4gIFx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKGNlbnRlciwgdGhpcy5fem9vbSwgdG9MYXRMbmdCb3VuZHMoYm91bmRzKSk7XHJcblxyXG4gIFx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG4gIFx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkluc2lkZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IHBhZGRpbmcgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcbiAgXHQvLyBwYWRkaW5nIG9wdGlvbnMgdG8gZml0IHRoZSBkaXNwbGF5IHRvIG1vcmUgcmVzdHJpY3RlZCBib3VuZHMuXHJcbiAgXHQvLyBJZiBgbGF0bG5nYCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgKG9wdGlvbmFsbHkgcGFkZGVkKSBkaXNwbGF5IGJvdW5kcyxcclxuICBcdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG4gIFx0cGFuSW5zaWRlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBwaXhlbENlbnRlciA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuICBcdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHBpeGVsQm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgcGFkZGVkQm91bmRzID0gdG9Cb3VuZHMoW3BpeGVsQm91bmRzLm1pbi5hZGQocGFkZGluZ1RMKSwgcGl4ZWxCb3VuZHMubWF4LnN1YnRyYWN0KHBhZGRpbmdCUildKSxcclxuICBcdFx0ICAgIHBhZGRlZFNpemUgPSBwYWRkZWRCb3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuICBcdFx0aWYgKCFwYWRkZWRCb3VuZHMuY29udGFpbnMocGl4ZWxQb2ludCkpIHtcclxuICBcdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG4gIFx0XHRcdHZhciBjZW50ZXJPZmZzZXQgPSBwaXhlbFBvaW50LnN1YnRyYWN0KHBhZGRlZEJvdW5kcy5nZXRDZW50ZXIoKSk7XHJcbiAgXHRcdFx0dmFyIG9mZnNldCA9IHBhZGRlZEJvdW5kcy5leHRlbmQocGl4ZWxQb2ludCkuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRlZFNpemUpO1xyXG4gIFx0XHRcdHBpeGVsQ2VudGVyLnggKz0gY2VudGVyT2Zmc2V0LnggPCAwID8gLW9mZnNldC54IDogb2Zmc2V0Lng7XHJcbiAgXHRcdFx0cGl4ZWxDZW50ZXIueSArPSBjZW50ZXJPZmZzZXQueSA8IDAgPyAtb2Zmc2V0LnkgOiBvZmZzZXQueTtcclxuICBcdFx0XHR0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KHBpeGVsQ2VudGVyKSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuICBcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG4gIFx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuICBcdC8vIElmIGBvcHRpb25zLmRlYm91bmNlTW92ZWVuZGAgaXMgYHRydWVgLCBpdCB3aWxsIGRlbGF5IGBtb3ZlZW5kYCBldmVudCBzb1xyXG4gIFx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuICBcdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG4gIFx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcbiAgXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuICBcdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IGV4dGVuZCh7XHJcbiAgXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcbiAgXHRcdFx0cGFuOiB0cnVlXHJcbiAgXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcbiAgXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuICBcdFx0dGhpcy5fbGFzdENlbnRlciA9IG51bGw7XHJcblxyXG4gIFx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG4gIFx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcbiAgXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuICBcdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcbiAgXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG4gIFx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG4gIFx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcbiAgXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG4gIFx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG4gIFx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG4gIFx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG4gIFx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuICBcdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gZXh0ZW5kKHtcclxuICBcdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuICBcdFx0XHR3YXRjaDogZmFsc2VcclxuICBcdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG4gIFx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcbiAgXHRcdFx0Ly8gbWF4aW11bUFnZTogMFxyXG4gIFx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuICBcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRpZiAoISgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikpIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuICBcdFx0XHRcdGNvZGU6IDAsXHJcbiAgXHRcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gbm90IHN1cHBvcnRlZC4nXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBvblJlc3BvbnNlID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLCB0aGlzKSxcclxuICBcdFx0ICAgIG9uRXJyb3IgPSBiaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuICBcdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG4gIFx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzdG9wTG9jYXRlKCk6IHRoaXNcclxuICBcdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG4gIFx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcbiAgXHQvLyBge3NldFZpZXc6IHRydWV9YC5cclxuICBcdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG4gIFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuICBcdFx0XHR0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBjID0gZXJyb3IuY29kZSxcclxuICBcdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcbiAgXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcbiAgXHRcdCAgICAgICAgICAgIChjID09PSAyID8gJ3Bvc2l0aW9uIHVuYXZhaWxhYmxlJyA6ICd0aW1lb3V0JykpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZCkgZmFpbGVkLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcbiAgXHRcdFx0Y29kZTogYyxcclxuICBcdFx0XHRtZXNzYWdlOiAnR2VvbG9jYXRpb24gZXJyb3I6ICcgKyBtZXNzYWdlICsgJy4nXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTogZnVuY3Rpb24gKHBvcykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG4gIFx0XHQgICAgbG5nID0gcG9zLmNvb3Jkcy5sb25naXR1ZGUsXHJcbiAgXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLnNldFZpZXcpIHtcclxuICBcdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG4gIFx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGRhdGEgPSB7XHJcbiAgXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcbiAgXHRcdFx0Ym91bmRzOiBib3VuZHMsXHJcbiAgXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHBvcy5jb29yZHMpIHtcclxuICBcdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcbiAgXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpXHJcbiAgXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gIFx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG4gIFx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcbiAgXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuICBcdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7IHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dHJ5IHtcclxuICBcdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkO1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuICBcdFx0fSBjYXRjaCAoZSkge1xyXG4gIFx0XHRcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRpb25XYXRjaElkICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLnN0b3BMb2NhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2NsZWFyQ29udHJvbFBvcykge1xyXG4gIFx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9yZXNpemVSZXF1ZXN0KSB7XHJcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jbGVhckhhbmRsZXJzKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgdW5sb2FkOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fbWFwUGFuZTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENyZWF0ZXMgYSBuZXcgW21hcCBwYW5lXSgjbWFwLXBhbmUpIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZG9lc24ndCBleGlzdCBhbHJlYWR5LFxyXG4gIFx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcbiAgXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcbiAgXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG4gIFx0XHQgICAgcGFuZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcbiAgXHRcdGlmIChuYW1lKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyLmNsb25lKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcbiAgXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuICBcdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcbiAgXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcbiAgXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcbiAgXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuICBcdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuICBcdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG4gIFx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG4gIFx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcbiAgXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG4gIFx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG4gIFx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG4gIFx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG4gIFx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuICBcdFx0aWYgKHNuYXApIHtcclxuICBcdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcbiAgXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcbiAgXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcbiAgXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuICBcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuICBcdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcbiAgXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuICBcdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG4gIFx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG4gIFx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcbiAgXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG4gIFx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG4gIFx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG4gIFx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcbiAgXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG4gIFx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG4gIFx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcbiAgXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcbiAgXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuICBcdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcbiAgXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuICBcdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcbiAgXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuICBcdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG4gIFx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG4gIFx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuICBcdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcbiAgXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG4gIFx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcbiAgXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuICBcdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG4gIFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG4gIFx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuICBcdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG4gIFx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcbiAgXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG4gIFx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG4gIFx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBnZXQoaWQpO1xyXG5cclxuICBcdFx0aWYgKCFjb250YWluZXIpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gc3RhbXAoY29udGFpbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcbiAgXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG4gIFx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG4gIFx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG4gIFx0XHR2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuICBcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBvc2l0aW9uICE9PSAnc3RpY2t5Jykge1xyXG4gIFx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcbiAgXHRcdHRoaXMuX3BhbmVSZW5kZXJlcnMgPSB7fTtcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIFBhbmVzIGFyZSBET00gZWxlbWVudHMgdXNlZCB0byBjb250cm9sIHRoZSBvcmRlcmluZyBvZiBsYXllcnMgb24gdGhlIG1hcC4gWW91XHJcbiAgXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG4gIFx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG4gIFx0XHQvLyBbYG1hcC5jcmVhdGVQYW5lYF0oI21hcC1jcmVhdGVwYW5lKSBtZXRob2QuXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG4gIFx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuICBcdFx0dGhpcy5fbWFwUGFuZSA9IHRoaXMuY3JlYXRlUGFuZSgnbWFwUGFuZScsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG4gIFx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCd0aWxlUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuICBcdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuICBcdFx0XHRhZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuICBcdFx0XHRhZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub01vdmVTdGFydCkge1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuICBcdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG4gIFx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG4gIFx0XHR6b29tID0gdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cclxuICBcdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcbiAgXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcbiAgXHRcdHRoaXNcclxuICBcdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpXHJcbiAgXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuICBcdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IHZpZXdyZXNldDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuICBcdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcbiAgXHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG4gIFx0XHQvLyBmb3IgdGhlIGZpcnN0IHRpbWUpLlxyXG4gIFx0XHRpZiAobG9hZGluZykge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCwgbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcbiAgXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhLCBzdXByZXNzRXZlbnQpIHtcclxuICBcdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG4gIFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuICBcdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuICBcdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuICBcdFx0aWYgKCFzdXByZXNzRXZlbnQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsXHJcbiAgXHRcdFx0Ly8gaW5jbHVkaW5nIHpvb20gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuICBcdFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsXHJcbiAgXHRcdFx0Ly8gaW5jbHVkaW5nIHBhbiBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLnBpbmNoKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuICBcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZ1xyXG4gIFx0XHQvLyAoZS5nLiB1c2VyIHN0b3BwZWQgZHJhZ2dpbmcgdGhlIG1hcCBvciBhZnRlciBub24tY2VudGVyZWQgem9vbSkuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG4gIFx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuICBcdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcbiAgXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcbiAgXHRcdHRoaXMuX3RhcmdldHNbc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuICBcdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gb2ZmIDogb247XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG4gIFx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcbiAgXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuICBcdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuICBcdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB0aGF0IHByb2R1Y2VzIGEgY2hhcmFjdGVyIHZhbHVlIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC4gVW5saWtlIHRoZSBga2V5cHJlc3NgIGV2ZW50LFxyXG4gIFx0XHQvLyB0aGUgYGtleWRvd25gIGV2ZW50IGlzIGZpcmVkIGZvciBrZXlzIHRoYXQgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZSBhbmQgZm9yIGtleXNcclxuICBcdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuICBcdFx0Ly8gQGV2ZW50IGtleXVwOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG4gIFx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuICBcdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG4gIFx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuICBcdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG4gIFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZShcclxuICBcdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcbiAgXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuICBcdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcbiAgXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwczovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuICBcdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG4gIFx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG4gIFx0XHQgICAgdGFyZ2V0LFxyXG4gIFx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcbiAgXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcbiAgXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICBcdFx0d2hpbGUgKHNyYykge1xyXG4gIFx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbc3RhbXAoc3JjKV07XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcbiAgXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuICBcdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuICBcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcbiAgXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcbiAgXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuICBcdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG4gIFx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIHRoaXMubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRhcmdldHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pc0NsaWNrRGlzYWJsZWQ6IGZ1bmN0aW9uIChlbCkge1xyXG4gIFx0XHR3aGlsZSAoZWwgJiYgZWwgIT09IHRoaXMuX2NvbnRhaW5lcikge1xyXG4gIFx0XHRcdGlmIChlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgXHRcdFx0ZWwgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIGVsID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IGVsWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9pc0NsaWNrRGlzYWJsZWQoZWwpKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJykge1xyXG4gIFx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKGVsKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG4gIFx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIGNhbnZhc1RhcmdldHMpIHtcclxuXHJcbiAgXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuICBcdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuICBcdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG4gIFx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG4gIFx0XHRcdHZhciBzeW50aCA9IGV4dGVuZCh7fSwgZSk7XHJcbiAgXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcbiAgXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCBjYW52YXNUYXJnZXRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG4gIFx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSk7XHJcblxyXG4gIFx0XHRpZiAoY2FudmFzVGFyZ2V0cykge1xyXG4gIFx0XHRcdHZhciBmaWx0ZXJlZCA9IFtdOyAvLyBwaWNrIG9ubHkgdGFyZ2V0cyB3aXRoIGxpc3RlbmVyc1xyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdFx0aWYgKGNhbnZhc1RhcmdldHNbaV0ubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGNhbnZhc1RhcmdldHNbaV0pO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHR0YXJnZXRzID0gZmlsdGVyZWQuY29uY2F0KHRhcmdldHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuICBcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcbiAgXHRcdHZhciBkYXRhID0ge1xyXG4gIFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcbiAgXHRcdFx0dmFyIGlzTWFya2VyID0gdGFyZ2V0LmdldExhdExuZyAmJiAoIXRhcmdldC5fcmFkaXVzIHx8IHRhcmdldC5fcmFkaXVzIDw9IDEwKTtcclxuICBcdFx0XHRkYXRhLmNvbnRhaW5lclBvaW50ID0gaXNNYXJrZXIgP1xyXG4gIFx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG4gIFx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcbiAgXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG4gIFx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuICBcdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG4gIFx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcbiAgXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuICBcdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuICBcdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG4gIFx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIGdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcbiAgXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuICBcdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcbiAgXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG4gIFx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG4gIFx0XHRdKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcbiAgXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcbiAgXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG4gIFx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcbiAgXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG4gIFx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuICBcdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG4gIFx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuICBcdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSA8PSAxICYmIE1hdGguYWJzKG9mZnNldC55KSA8PSAxKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG4gIFx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuICBcdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcbiAgXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuICBcdFx0ICAgICksXHJcbiAgXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcbiAgXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG4gIFx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG4gIFx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcbiAgXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuICBcdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuICBcdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuICBcdFx0aWYgKHNuYXApIHtcclxuICBcdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcbiAgXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcbiAgXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG4gIFx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuICBcdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG4gIFx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0dmFyIHByb3AgPSBUUkFOU0ZPUk0sXHJcbiAgXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuICBcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG4gIFx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcbiAgXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9wcm94eSk7XHJcbiAgXHRcdHRoaXMub2ZmKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuICBcdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuICBcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG4gIFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG4gIFx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHR0aGlzXHJcbiAgXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQgfHwgZmFsc2UpXHJcbiAgXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwUGFuZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChzdGFydEFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvQ2VudGVyID0gY2VudGVyO1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gT3RoZXIgRXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG4gIFx0XHQvLyBGaXJlZCBhdCBsZWFzdCBvbmNlIHBlciB6b29tIGFuaW1hdGlvbi4gRm9yIGNvbnRpbnVvdXMgem9vbSwgbGlrZSBwaW5jaCB6b29taW5nLCBmaXJlZCBvbmNlIHBlciBmcmFtZSBkdXJpbmcgem9vbS5cclxuICBcdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuICBcdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuICBcdFx0XHR6b29tOiB6b29tLFxyXG4gIFx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuICBcdFx0XHR0aGlzLl90ZW1wRmlyZVpvb21FdmVudCA9IHRoaXMuX3pvb20gIT09IHRoaXMuX2FuaW1hdGVUb1pvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuICBcdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG4gIFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0ZGVsZXRlIHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50O1xyXG5cclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAc2VjdGlvblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbiAgLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4gIC8vXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbiAgLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBNYXAoaWQsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sXHJcbiAgICogQGFrYSBMLkNvbnRyb2xcclxuICAgKiBAaW5oZXJpdHMgQ2xhc3NcclxuICAgKlxyXG4gICAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAgICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAgICovXHJcblxyXG4gIHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wgT3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcbiAgXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcbiAgXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuICBcdCAqXHJcbiAgXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuICBcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG4gIFx0ICovXHJcbiAgXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuICBcdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcbiAgXHRcdGlmIChtYXApIHtcclxuICBcdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG4gIFx0XHRpZiAobWFwKSB7XHJcbiAgXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuICBcdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMucmVtb3ZlKCk7XHJcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcbiAgXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcbiAgXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcbiAgXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcbiAgXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXHJcbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG4gIFx0XHRcdHRoaXMub25SZW1vdmUodGhpcy5fbWFwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG4gIFx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IENvbnRyb2wob3B0aW9ucyk7XHJcbiAgfTtcclxuXHJcbiAgLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICAgKiBAdW5pbmhlcml0YWJsZVxyXG4gICAqXHJcbiAgICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICAgKlxyXG4gICAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gICAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICAgKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAgICovXHJcblxyXG4gIC8qIEBuYW1lc3BhY2UgTWFwXHJcbiAgICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gICAqL1xyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gY29udHJvbCB0byB0aGUgbWFwXHJcbiAgXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gIFx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcFxyXG4gIFx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICBcdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcbiAgXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG4gIFx0XHQgICAgICAgICAgICBjcmVhdGUkMSgnZGl2JywgbCArICdjb250cm9sLWNvbnRhaW5lcicsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcbiAgXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcbiAgXHRcdFx0Y29ybmVyc1t2U2lkZSArIGhTaWRlXSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuICBcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuICBcdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuICBcdH1cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gICAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAgICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAgICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIHZhciBvdmVybGF5cyA9IHtcclxuICAgKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICAgKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7XHJcbiAgICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gICAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyLCB0b3VjaCwgb3Iga2V5Ym9hcmQgYWN0aXZhdGlvbi5cclxuICBcdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG4gIFx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuICBcdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG4gIFx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIGxheWVycy4gV2hlbiBgZmFsc2VgLCBsYXllcnMgd2lsbCBrZWVwIHRoZSBvcmRlclxyXG4gIFx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcbiAgXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzb3J0RnVuY3Rpb246IEZ1bmN0aW9uID0gKlxyXG4gIFx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG4gIFx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcbiAgXHRcdC8vIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBib3RoIHRoZSBgTC5MYXllcmAgaW5zdGFuY2VzIGFuZCB0aGVpciBuYW1lcywgYXMgaW5cclxuICBcdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG4gIFx0XHRzb3J0RnVuY3Rpb246IGZ1bmN0aW9uIChsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG4gIFx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuICBcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuICBcdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcbiAgXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuICBcdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcbiAgXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihzdGFtcChsYXllcikpO1xyXG4gIFx0XHRpZiAob2JqKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuICBcdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG4gIFx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuICBcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG4gIFx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG4gIFx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0KSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuICBcdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuICBcdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcclxuICBcdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG4gIFx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcbiAgXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcbiAgXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuICBcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uID0gY3JlYXRlJDEoJ3NlY3Rpb24nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcbiAgXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRcdG9uKGNvbnRhaW5lciwge1xyXG4gIFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5fZXhwYW5kU2FmZWx5LFxyXG4gIFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuICBcdFx0b24obGluaywge1xyXG4gIFx0XHRcdGtleWRvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG4gIFx0XHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9LFxyXG4gIFx0XHRcdC8vIENlcnRhaW4gc2NyZWVuIHJlYWRlcnMgaW50ZXJjZXB0IHRoZSBrZXkgZXZlbnQgYW5kIGluc3RlYWQgc2VuZCBhIGNsaWNrIGV2ZW50XHJcbiAgXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuICBcdFx0XHRcdHRoaXMuX2V4cGFuZFNhZmVseSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3IgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBzdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuICBcdFx0XHRsYXllcjogbGF5ZXIsXHJcbiAgXHRcdFx0bmFtZTogbmFtZSxcclxuICBcdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG4gIFx0XHRcdH0sIHRoaXMpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuICBcdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuICBcdFx0ZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG4gIFx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcbiAgXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcbiAgXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG4gIFx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG4gIFx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcbiAgXHRcdGlmICh0eXBlKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwNzkpXHJcbiAgXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuICBcdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG4gIFx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuICBcdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG4gIFx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG4gIFx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG4gIFx0XHQgICAgaW5wdXQ7XHJcblxyXG4gIFx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuICBcdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcbiAgXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG4gIFx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcbiAgXHRcdGlucHV0LmxheWVySWQgPSBzdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuICBcdFx0b24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICBcdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcbiAgXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcbiAgXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblxyXG4gIFx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuICBcdFx0cmV0dXJuIGxhYmVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIGV4cGFuZGluZyB0aGUgY29udHJvbCBvbiBtb2JpbGUgd2l0aCBhIGNsaWNrIGNhbiBjYXVzZSBhZGRpbmcgYSBsYXllciAtIHdlIGRvbid0IHdhbnQgdGhpc1xyXG4gIFx0XHRpZiAodGhpcy5fcHJldmVudENsaWNrKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG4gIFx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuICBcdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG4gIFx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcbiAgXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuICBcdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuICBcdFx0ICAgIGlucHV0LFxyXG4gIFx0XHQgICAgbGF5ZXIsXHJcbiAgXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICBcdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG4gIFx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcbiAgXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZFNhZmVseTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcbiAgXHRcdHRoaXMuX3ByZXZlbnRDbGljayA9IHRydWU7XHJcbiAgXHRcdG9uKHNlY3Rpb24sICdjbGljaycsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0dmFyIHRoYXQgPSB0aGlzO1xyXG4gIFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRvZmYoc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHRcdHRoYXQuX3ByZXZlbnRDbGljayA9IGZhbHNlO1xyXG4gIFx0XHR9KTtcclxuICBcdH1cclxuXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG4gIHZhciBsYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gICAqIEBha2EgTC5Db250cm9sLlpvb21cclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogQSBiYXNpYyB6b29tIGNvbnRyb2wgd2l0aCB0d28gYnV0dG9ucyAoem9vbSBpbiBhbmQgem9vbSBvdXQpLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHRvIGBmYWxzZWAuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gICAqL1xyXG5cclxuICB2YXIgWm9vbSA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPidcclxuICBcdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG4gIFx0XHR6b29tSW5UZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcbiAgXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcbiAgXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+J1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG4gIFx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuICBcdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuICBcdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcbiAgXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuICBcdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuICBcdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG4gIFx0XHR2YXIgbGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG4gIFx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcbiAgXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuICBcdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuICBcdFx0LypcclxuICBcdFx0ICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuICBcdFx0ICovXHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG4gIFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBzdG9wKTtcclxuICBcdFx0b24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxpbms7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG4gIFx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcbiAgXHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0XHR0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4gIC8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbiAgLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdHpvb21Db250cm9sOiB0cnVlXHJcbiAgfSk7XHJcblxyXG4gIE1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcbiAgXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSB6b29tQ29udHJvbDogQ29udHJvbC5ab29tXHJcbiAgXHRcdC8vIFRoZSBkZWZhdWx0IHpvb20gY29udHJvbCAob25seSBhdmFpbGFibGUgaWYgdGhlXHJcbiAgXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG4gIFx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuICBcdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuICB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICAgKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxuICAgKlxuICAgKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBTY2FsZSA9IENvbnRyb2wuZXh0ZW5kKHtcbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG4gIFx0XHQvLyBNYXhpbXVtIHdpZHRoIG9mIHRoZSBjb250cm9sIGluIHBpeGVscy4gVGhlIHdpZHRoIGlzIHNldCBkeW5hbWljYWxseSB0byBzaG93IHJvdW5kIHZhbHVlcyAoZS5nLiAxMDAsIDIwMCwgNTAwKS5cbiAgXHRcdG1heFdpZHRoOiAxMDAsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuICBcdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBtZXRyaWMgc2NhbGUgbGluZSAobS9rbSkuXG4gIFx0XHRtZXRyaWM6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIGltcGVyaWFsIHNjYWxlIGxpbmUgKG1pL2Z0KS5cbiAgXHRcdGltcGVyaWFsOiB0cnVlXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCBpcyB1cGRhdGVkIG9uIFtgbW92ZWVuZGBdKCNtYXAtbW92ZWVuZCksIG90aGVyd2lzZSBpdCdzIGFsd2F5cyB1cC10by1kYXRlICh1cGRhdGVkIG9uIFtgbW92ZWBdKCNtYXAtbW92ZSkpLlxuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtc2NhbGUnLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpLFxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG4gIFx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuICBcdFx0cmV0dXJuIGNvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcbiAgXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuICBcdFx0XHR0aGlzLl9tU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuICBcdFx0fVxuICBcdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcbiAgXHRcdFx0dGhpcy5faVNjYWxlID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB5ID0gbWFwLmdldFNpemUoKS55IC8gMjtcblxuICBcdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcbiAgXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcbiAgXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuICBcdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuICBcdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuICBcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG4gIFx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcbiAgXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cbiAgXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuICBcdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuICBcdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcbiAgXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuICBcdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcbiAgXHR9LFxuXG4gIFx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG4gIFx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcbiAgXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cbiAgXHRcdGQgPSBkID49IDEwID8gMTAgOlxuICBcdFx0ICAgIGQgPj0gNSA/IDUgOlxuICBcdFx0ICAgIGQgPj0gMyA/IDMgOlxuICBcdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG4gIFx0XHRyZXR1cm4gcG93MTAgKiBkO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbiAgfTtcblxuICB2YXIgdWtyYWluaWFuRmxhZyA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICAgKi9cclxuXHJcbiAgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZ3xmYWxzZSA9ICdMZWFmbGV0J1xyXG4gIFx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj4nICsgKEJyb3dzZXIuaW5saW5lU3ZnID8gdWtyYWluaWFuRmxhZyArICcgJyA6ICcnKSArICdMZWFmbGV0PC9hPidcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuICBcdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG4gIFx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0bWFwLm9uKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkQXR0cmlidXRpb246IGZ1bmN0aW9uIChldikge1xyXG4gIFx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdGV2LmxheWVyLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmd8ZmFsc2UpOiB0aGlzXHJcbiAgXHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnJmNvcHk7IE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ2ApLlxyXG4gIFx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuICBcdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcbiAgXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuICBcdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG4gIFx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcbiAgXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+fDwvc3Bhbj4gJyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbiAgLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbiAgfSk7XHJcblxyXG4gIE1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG4gIFx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbiAgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbiAgfTtcblxuICBDb250cm9sLkxheWVycyA9IExheWVycztcbiAgQ29udHJvbC5ab29tID0gWm9vbTtcbiAgQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuICBDb250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbiAgY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG4gIGNvbnRyb2wuem9vbSA9IHpvb207XG4gIGNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbiAgY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG4gIC8qXG4gIFx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3RcbiAgXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiAgKi9cblxuICAvLyBAY2xhc3MgSGFuZGxlclxuICAvLyBAYWthIEwuSGFuZGxlclxuICAvLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbiAgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKTogdGhpc1xuICBcdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5hZGRIb29rcygpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGhhbmRsZXJcbiAgXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuICBcdGVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG4gIFx0fVxuXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcbiAgXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBlbmFibGVkLCBzaG91bGQgYWRkIGV2ZW50IGhvb2tzLlxuICBcdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuICBcdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuICAvLyBAZnVuY3Rpb24gYWRkVG8obWFwOiBNYXAsIG5hbWU6IFN0cmluZyk6IHRoaXNcbiAgLy8gQWRkcyBhIG5ldyBIYW5kbGVyIHRvIHRoZSBnaXZlbiBtYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgXHRtYXAuYWRkSGFuZGxlcihuYW1lLCB0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIERyYWdnYWJsZVxyXG4gICAqIEBha2EgTC5EcmFnZ2FibGVcclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gICAqXHJcbiAgICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gICAqIHRoYXQgd2VyZSBwb3NpdGlvbmVkIHdpdGggW2BMLkRvbVV0aWwuc2V0UG9zaXRpb25gXSgjZG9tdXRpbC1zZXRwb3NpdGlvbikuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICAgKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBTVEFSVCA9IEJyb3dzZXIudG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XHJcblxyXG4gIHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvblxyXG4gIFx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuICBcdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuICBcdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG4gIFx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG4gIFx0Ly8gQ3JlYXRlcyBhIGBEcmFnZ2FibGVgIG9iamVjdCBmb3IgbW92aW5nIGBlbGAgd2hlbiB5b3Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGBkcmFnSGFuZGxlYCBlbGVtZW50IChlcXVhbHMgYGVsYCBpdHNlbGYgYnkgZGVmYXVsdCkuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG4gIFx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcbiAgXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRvbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcbiAgXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcbiAgXHRcdC8vIGRpc2FibGluZyBpdCBjb3VudHMgYXMgZmlyc3QgZW5kaW5nIHRoZSBkcmFnLlxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG4gIFx0XHRcdHRoaXMuZmluaXNoRHJhZyh0cnVlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0b2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuICBcdFx0aWYgKGhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgXHRcdFx0Ly8gRmluaXNoIGRyYWdnaW5nIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggdG91Y2hab29tXHJcbiAgXHRcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuICBcdFx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG4gIFx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcbiAgXHRcdFx0cHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcclxuICBcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcbiAgXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcclxuICBcdFx0ICAgIHNpemVkUGFyZW50ID0gZ2V0U2l6ZWRQYXJlbnROb2RlKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICBcdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuICBcdFx0dGhpcy5fc3RhcnRQb3MgPSBnZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdC8vIENhY2hlIHRoZSBzY2FsZSwgc28gdGhhdCB3ZSBjYW4gY29udGludW91c2x5IGNvbXBlbnNhdGUgZm9yIGl0IGR1cmluZyBkcmFnIChfb25Nb3ZlKS5cclxuICBcdFx0dGhpcy5fcGFyZW50U2NhbGUgPSBnZXRTY2FsZShzaXplZFBhcmVudCk7XHJcblxyXG4gIFx0XHR2YXIgbW91c2VldmVudCA9IGUudHlwZSA9PT0gJ21vdXNlZG93bic7XHJcbiAgXHRcdG9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNlbW92ZScgOiAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b24oZG9jdW1lbnQsIG1vdXNlZXZlbnQgPyAnbW91c2V1cCcgOiAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gSWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuICBcdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcbiAgXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuICBcdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG4gIFx0XHQvLyBUaGVyZWZvcmUgdGhlcmUgaXMgbm8gbmVlZCB0byBhY2NvdW50IGZvciB0aGUgcG9zaXRpb24gYW5kIGJvcmRlciAodGhleSBhcmUgZWxpbWluYXRlZCBieSB0aGUgc3VidHJhY3Rpb24pXHJcbiAgXHRcdC8vIGFuZCB3ZSBjYW4gdXNlIHRoZSBjYWNoZWQgdmFsdWUgZm9yIHRoZSBzY2FsZS5cclxuICBcdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuICBcdFx0b2Zmc2V0LnkgLz0gdGhpcy5fcGFyZW50U2NhbGUueTtcclxuXHJcbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG4gIFx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cclxuICBcdFx0XHRhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG4gIFx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG4gIFx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG4gIFx0XHRcdGlmICh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlICYmIHRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcbiAgXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXN0RXZlbnQgPSBlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG4gIFx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuICBcdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuICBcdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAobm9JbmVydGlhKSB7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcbiAgXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG4gIFx0XHRvZmYoZG9jdW1lbnQsICdtb3VzZXVwIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblxyXG4gIFx0XHRlbmFibGVJbWFnZURyYWcoKTtcclxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuICBcdFx0dmFyIGZpcmVEcmFnZW5kID0gdGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nO1xyXG5cclxuICBcdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcbiAgXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChmaXJlRHJhZ2VuZCkge1xyXG4gIFx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG4gIFx0XHRcdFx0bm9JbmVydGlhOiBub0luZXJ0aWEsXHJcbiAgXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gICAqL1xyXG5cclxuICAvKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gICAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAgICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICAgKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAgICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcbiAgXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuICBcdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuICBcdCAgICBpLCBqLCBrLFxyXG4gIFx0ICAgIGEsIGIsXHJcbiAgXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuICBcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRwb2ludHNbaV0uX2NvZGUgPSBfZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG4gIFx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG4gIFx0XHRlZGdlID0gZWRnZXNba107XHJcbiAgXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcbiAgXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuICBcdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuICBcdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuICBcdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG4gIFx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcbiAgXHRcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcbiAgXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcbiAgXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcbiAgXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG4gIFx0XHRcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG4gIFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHBvaW50cztcclxuICB9XHJcblxyXG4gIC8qIEBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gICAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWdvbi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG4gIFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyO1xyXG5cclxuICBcdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmICghaXNGbGF0KGxhdGxuZ3MpKSB7XHJcbiAgXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG4gIFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG4gIFx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuICBcdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuICBcdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG4gIFx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuICBcdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcbiAgXHR2YXIgcG9pbnRzID0gW107XHJcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG4gIFx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0YXJlYSA9IHggPSB5ID0gMDtcclxuXHJcbiAgXHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTtcclxuICBcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcbiAgXHRcdHAxID0gcG9pbnRzW2ldO1xyXG4gIFx0XHRwMiA9IHBvaW50c1tqXTtcclxuXHJcbiAgXHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xyXG4gIFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xyXG4gIFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xyXG4gIFx0XHRhcmVhICs9IGYgKiAzO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmIChhcmVhID09PSAwKSB7XHJcbiAgXHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxyXG4gIFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG4gIFx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbiAgfVxyXG5cclxuICAvKiBAZnVuY3Rpb24gY2VudHJvaWQobGF0bG5nczogTGF0TG5nW10pOiBMYXRMbmdcclxuICAgKiBSZXR1cm5zIHRoZSAnY2VudGVyIG9mIG1hc3MnIG9mIHRoZSBwYXNzZWQgTGF0TG5ncy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjZW50cm9pZChjb29yZHMpIHtcclxuICBcdHZhciBsYXRTdW0gPSAwO1xyXG4gIFx0dmFyIGxuZ1N1bSA9IDA7XHJcbiAgXHR2YXIgbGVuID0gMDtcclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhjb29yZHNbaV0pO1xyXG4gIFx0XHRsYXRTdW0gKz0gbGF0bG5nLmxhdDtcclxuICBcdFx0bG5nU3VtICs9IGxhdGxuZy5sbmc7XHJcbiAgXHRcdGxlbisrO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHRvTGF0TG5nKFtsYXRTdW0gLyBsZW4sIGxuZ1N1bSAvIGxlbl0pO1xyXG4gIH1cblxuICB2YXIgUG9seVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNsaXBQb2x5Z29uOiBjbGlwUG9seWdvbixcbiAgICBwb2x5Z29uQ2VudGVyOiBwb2x5Z29uQ2VudGVyLFxuICAgIGNlbnRyb2lkOiBjZW50cm9pZFxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gICAqXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWxpbmUgcG9pbnRzIHByb2Nlc3NpbmcsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIG1ha2UgcG9seWxpbmVzIGxpZ2h0bmluZy1mYXN0LlxyXG4gICAqL1xyXG5cclxuICAvLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuICAvLyBJbXByb3ZlcyByZW5kZXJpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IGJ5IGxlc3NlbmluZyB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3LlxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuICAvLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4gIC8vIGl0cyBzaGFwZSBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBzaW1wbGlmaWVkIHBvaW50cywgdXNpbmcgdGhlXHJcbiAgLy8gW1JhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4gIC8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuICAvLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbiAgLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuICAvLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwczovL21vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzLykuXHJcbiAgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuICBcdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcbiAgXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuICBcdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuICBcdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcbiAgXHRyZXR1cm4gcG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG4gIGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG4gIFx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmFtZXItRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG4gIGZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcbiAgXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuICBcdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG4gIFx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuICBcdCAgICBtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG4gIFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuICBcdHZhciBpLFxyXG4gIFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG4gIFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbmV3UG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG4gIFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcbiAgXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuICBcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcbiAgXHRcdHNxRGlzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG4gIFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcbiAgXHRcdFx0aW5kZXggPSBpO1xyXG4gIFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG4gIFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG4gIFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuICBcdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuICBmdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuICBcdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuICBcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuICBcdFx0XHRwcmV2ID0gaTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcbiAgXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcbiAgfVxyXG5cclxuICB2YXIgX2xhc3RDb2RlO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuICAvLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbiAgLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4gIC8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuICAvLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG4gIGZ1bmN0aW9uIGNsaXBTZWdtZW50KGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUsIHJvdW5kKSB7XHJcbiAgXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcbiAgXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuICBcdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuICBcdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuICBcdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcbiAgXHR3aGlsZSAodHJ1ZSkge1xyXG4gIFx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcbiAgXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIFthLCBiXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuICBcdFx0aWYgKGNvZGVBICYgY29kZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIG90aGVyIGNhc2VzXHJcbiAgXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuICBcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG4gIFx0XHRuZXdDb2RlID0gX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG4gIFx0XHRcdGEgPSBwO1xyXG4gIFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRiID0gcDtcclxuICBcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuICBcdHZhciBkeCA9IGIueCAtIGEueCxcclxuICBcdCAgICBkeSA9IGIueSAtIGEueSxcclxuICBcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG4gIFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcbiAgXHQgICAgeCwgeTtcclxuXHJcbiAgXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcbiAgXHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuICBcdFx0eSA9IG1heC55O1xyXG5cclxuICBcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcbiAgXHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuICBcdFx0eSA9IG1pbi55O1xyXG5cclxuICBcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuICBcdFx0eCA9IG1heC54O1xyXG4gIFx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcbiAgXHRcdHggPSBtaW4ueDtcclxuICBcdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2dldEJpdENvZGUocCwgYm91bmRzKSB7XHJcbiAgXHR2YXIgY29kZSA9IDA7XHJcblxyXG4gIFx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcbiAgXHRcdGNvZGUgfD0gMTtcclxuICBcdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcbiAgXHRcdGNvZGUgfD0gMjtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHRjb2RlIHw9IDQ7XHJcbiAgXHR9IGVsc2UgaWYgKHAueSA+IGJvdW5kcy5tYXgueSkgeyAvLyB0b3BcclxuICBcdFx0Y29kZSB8PSA4O1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBjb2RlO1xyXG4gIH1cclxuXHJcbiAgLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbiAgZnVuY3Rpb24gX3NxRGlzdChwMSwgcDIpIHtcclxuICBcdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG4gIFx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcbiAgXHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuICBmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuICBcdHZhciB4ID0gcDEueCxcclxuICBcdCAgICB5ID0gcDEueSxcclxuICBcdCAgICBkeCA9IHAyLnggLSB4LFxyXG4gIFx0ICAgIGR5ID0gcDIueSAtIHksXHJcbiAgXHQgICAgZG90ID0gZHggKiBkeCArIGR5ICogZHksXHJcbiAgXHQgICAgdDtcclxuXHJcbiAgXHRpZiAoZG90ID4gMCkge1xyXG4gIFx0XHR0ID0gKChwLnggLSB4KSAqIGR4ICsgKHAueSAtIHkpICogZHkpIC8gZG90O1xyXG5cclxuICBcdFx0aWYgKHQgPiAxKSB7XHJcbiAgXHRcdFx0eCA9IHAyLng7XHJcbiAgXHRcdFx0eSA9IHAyLnk7XHJcbiAgXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuICBcdFx0XHR4ICs9IGR4ICogdDtcclxuICBcdFx0XHR5ICs9IGR5ICogdDtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdGR4ID0gcC54IC0geDtcclxuICBcdGR5ID0gcC55IC0geTtcclxuXHJcbiAgXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuICAvLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG4gIGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzKSB7XHJcbiAgXHRyZXR1cm4gIWlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2ZsYXQobGF0bG5ncykge1xyXG4gIFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG4gIFx0cmV0dXJuIGlzRmxhdChsYXRsbmdzKTtcclxuICB9XHJcblxyXG4gIC8qIEBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlsaW5lLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3MsIGNycykge1xyXG4gIFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLCBjZW50ZXI7XHJcblxyXG4gIFx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuICBcdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuICBcdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGNlbnRyb2lkTGF0TG5nID0gdG9MYXRMbmcoWzAsIDBdKTtcclxuXHJcbiAgXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcbiAgXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG4gIFx0Ly8gdGVzdHMgc2hvd2VkIHRoYXQgYmVsb3cgMTcwMCByb3VuZGluZyBlcnJvcnMgYXJlIGhhcHBlbmluZ1xyXG4gIFx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcbiAgXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG4gIFx0XHRjZW50cm9pZExhdExuZyA9IGNlbnRyb2lkKGxhdGxuZ3MpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuICBcdHZhciBwb2ludHMgPSBbXTtcclxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcbiAgXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKFtsYXRsbmcubGF0IC0gY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmcubG5nIC0gY2VudHJvaWRMYXRMbmcubG5nXSkpKTtcclxuICBcdH1cclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuICBcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuICBcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xyXG4gIFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG4gIFx0XHRcdHAxID0gcG9pbnRzW2ldO1xyXG4gIFx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuICBcdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XHJcbiAgXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xyXG5cclxuICBcdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcbiAgXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcclxuICBcdFx0XHRcdGNlbnRlciA9IFtcclxuICBcdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuICBcdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxyXG4gIFx0XHRcdFx0XTtcclxuICBcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHZhciBsYXRsbmdDZW50ZXIgPSBjcnMudW5wcm9qZWN0KHRvUG9pbnQoY2VudGVyKSk7XHJcbiAgXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxuICB9XG5cbiAgdmFyIExpbmVVdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBzaW1wbGlmeTogc2ltcGxpZnksXG4gICAgcG9pbnRUb1NlZ21lbnREaXN0YW5jZTogcG9pbnRUb1NlZ21lbnREaXN0YW5jZSxcbiAgICBjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgICBjbGlwU2VnbWVudDogY2xpcFNlZ21lbnQsXG4gICAgX2dldEVkZ2VJbnRlcnNlY3Rpb246IF9nZXRFZGdlSW50ZXJzZWN0aW9uLFxuICAgIF9nZXRCaXRDb2RlOiBfZ2V0Qml0Q29kZSxcbiAgICBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgICBpc0ZsYXQ6IGlzRmxhdCxcbiAgICBfZmxhdDogX2ZsYXQsXG4gICAgcG9seWxpbmVDZW50ZXI6IHBvbHlsaW5lQ2VudGVyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAc2VjdGlvblxyXG4gICAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAgICpcclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAgICpcclxuICAgKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICAgKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gICAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAgICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIExvbkxhdCA9IHtcclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICAgKlxyXG4gICAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgTWVyY2F0b3IgPSB7XHJcbiAgXHRSOiA2Mzc4MTM3LFxyXG4gIFx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG4gIFx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuICBcdFx0ICAgIHIgPSB0aGlzLlIsXHJcbiAgXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcbiAgXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG4gIFx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuICBcdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcbiAgXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcbiAgXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcbiAgXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcbiAgXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcbiAgXHRcdFx0cGhpICs9IGRwaGk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcbiAgXHR9XHJcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gICAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gICAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICAgKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAgICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICAgKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICAgKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICAgKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICAgKi9cblxuICB2YXIgaW5kZXggPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIExvbkxhdDogTG9uTGF0LFxuICAgIE1lcmNhdG9yOiBNZXJjYXRvcixcbiAgICBTcGhlcmljYWxNZXJjYXRvcjogU3BoZXJpY2FsTWVyY2F0b3JcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gICAqXHJcbiAgICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICAgKi9cclxuICB2YXIgRVBTRzMzOTUgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuICBcdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuICBcdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG4gIFx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcbiAgXHR9KCkpXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICAgKlxyXG4gICAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICAgKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gICAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICAgKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAgICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHNDMyNiA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG4gIFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxuICB9KTtcblxuICAvKlxuICAgKiBAbmFtZXNwYWNlIENSU1xuICAgKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICAgKlxuICAgKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAgICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICAgKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAgICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAgICovXG5cbiAgdmFyIFNpbXBsZSA9IGV4dGVuZCh7fSwgQ1JTLCB7XG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuICBcdH0sXG5cbiAgXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcbiAgXHR9LFxuXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuICBcdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuICBcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFx0fSxcblxuICBcdGluZmluaXRlOiB0cnVlXG4gIH0pO1xuXG4gIENSUy5FYXJ0aCA9IEVhcnRoO1xuICBDUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbiAgQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG4gIENSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbiAgQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG4gIENSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbiAgLypcbiAgICogQGNsYXNzIExheWVyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXG4gICAqIEBha2EgTC5MYXllclxuICAgKiBAYWthIElMYXllclxuICAgKlxuICAgKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICAgKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIucmVtb3ZlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXZlbnQgYWRkOiBFdmVudFxuICAgKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAgICpcbiAgICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICAgKi9cblxuXG4gIHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuICBcdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuICBcdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG4gIFx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHQvKiBAc2VjdGlvblxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICBcdCAqXG4gIFx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuICBcdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG4gIFx0ICovXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG4gIFx0Ly9cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG4gIFx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuICBcdFx0aWYgKG9iaikge1xuICBcdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuICBcdH0sXG5cbiAgXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG4gIFx0XHR0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tzdGFtcCh0YXJnZXRFbCldO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuICBcdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG4gIFx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG4gIFx0fSxcblxuICBcdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuICBcdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuICBcdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG4gIFx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuICBcdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuICBcdFx0XHR9LCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vbkFkZChtYXApO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuICBcdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG4gIFx0fVxuICB9KTtcblxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICAgKiBAdW5pbmhlcml0YWJsZVxuICAgKlxuICAgKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gICAqXG4gICAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAgICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICpcbiAgICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFwXG4gICAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gICAqXG4gICAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgICovXG4gIE1hcC5pbmNsdWRlKHtcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG4gIFx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG4gIFx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG4gIFx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG4gIFx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuICBcdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcbiAgXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG4gIFx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnM7XG4gIFx0fSxcblxuICBcdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcbiAgXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICBcdCAqIGBgYFxuICBcdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuICBcdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG4gIFx0ICogfSk7XG4gIFx0ICogYGBgXG4gIFx0ICovXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcbiAgXHRcdGxheWVycyA9IGxheWVycyA/IChpc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG4gIFx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuICBcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG4gIFx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuICBcdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG4gIFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG4gIFx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cbiAgXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gICAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICAgKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICAgKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gICAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gICAqIFx0LmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdHZhciBpLCBsZW47XHJcblxyXG4gIFx0XHRpZiAobGF5ZXJzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGxheWVySWQgPSB0eXBlb2YgbGF5ZXIgPT09ICdudW1iZXInID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuICBcdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcbiAgXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcbiAgXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG4gIFx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gIFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgXHRcdCAgICBpLCBsYXllcjtcclxuXHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcbiAgXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcbiAgXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuICBcdC8vIGBgYGpzXHJcbiAgXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuICBcdC8vIH0pO1xyXG4gIFx0Ly8gYGBgXHJcbiAgXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcbiAgXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcbiAgXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuICBcdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICAgKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAgICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICAgKlxyXG4gICAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAgICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAgICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gICAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gICAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gICAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICAgKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAgICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBib3VuZHM7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBJY29uXHJcbiAgICogQGFrYSBMLkljb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICAgKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICAgKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICAgKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gICAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICAgKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICAgKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICAgKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICAgKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAgICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuICBcdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcbiAgXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcbiAgXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcbiAgXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG4gIFx0ICovXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG4gIFx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcbiAgXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcbiAgXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuICBcdFx0aWYgKCFzcmMpIHtcclxuICBcdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG4gIFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGltZztcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc2l6ZSA9IHRvUG9pbnQoc2l6ZU9wdGlvbiksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0b1BvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG4gIFx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuICBcdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG4gIFx0XHRpZiAoYW5jaG9yKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChzaXplKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuICBcdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICBcdFx0ZWwuc3JjID0gc3JjO1xyXG4gIFx0XHRyZXR1cm4gZWw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gIFx0XHRyZXR1cm4gQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAgICogQGFrYSBMLkljb24uRGVmYXVsdFxuICAgKiBAc2VjdGlvblxuICAgKlxuICAgKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICAgKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAgICogcmVsZWFzZXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gICAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICAgKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gICAqL1xuXG4gIHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuICBcdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG4gIFx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuICBcdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuICBcdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuICBcdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuICBcdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG4gIFx0fSxcblxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKHR5cGVvZiBJY29uRGVmYXVsdC5pbWFnZVBhdGggIT09ICdzdHJpbmcnKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG4gIFx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcbiAgXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcbiAgXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuICBcdH0sXG5cbiAgXHRfc3RyaXBVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XHQvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byB1c2UgaW4gdGVzdHNcbiAgXHRcdHZhciBzdHJpcCA9IGZ1bmN0aW9uIChzdHIsIHJlLCBpZHgpIHtcbiAgXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbaWR4XTtcbiAgXHRcdH07XG4gIFx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG4gIFx0XHRyZXR1cm4gcGF0aCAmJiBzdHJpcChwYXRoLCAvXiguKiltYXJrZXItaWNvblxcLnBuZyQvLCAxKTtcbiAgXHR9LFxuXG4gIFx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWwgPSBjcmVhdGUkMSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG4gIFx0XHR2YXIgcGF0aCA9IGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG4gIFx0XHQgICAgICAgICAgIGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuICBcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gIFx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG4gIFx0XHRpZiAocGF0aCkgeyByZXR1cm4gcGF0aDsgfVxuICBcdFx0dmFyIGxpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWYkPVwibGVhZmxldC5jc3NcIl0nKTtcbiAgXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cbiAgXHRcdHJldHVybiBsaW5rLmhyZWYuc3Vic3RyaW5nKDAsIGxpbmsuaHJlZi5sZW5ndGggLSAnbGVhZmxldC5jc3MnLmxlbmd0aCAtIDEpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFya2VyXG4gICAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gICAqXG4gICAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICAgKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAgICovXG5cbiAgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuICBcdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cbiAgXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcbiAgXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG4gIFx0XHRhZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcbiAgXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuICBcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcbiAgXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcbiAgXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcbiAgXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG4gIFx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cbiAgXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcbiAgXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG4gIFx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcbiAgXHRcdCk7XG5cbiAgXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG4gIFx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcbiAgXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcbiAgXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cbiAgXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG4gIFx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG4gIFx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuICBcdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG4gIFx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cbiAgXHRcdFx0c2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG4gIFx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuICBcdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuICBcdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXG4gIFx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuICBcdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0dGhpcy5fbWFya2VyXG4gIFx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuICBcdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG4gIFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG4gIFx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG4gIFx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG4gIFx0XHRpZiAoc2hhZG93KSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG4gIFx0XHR9XG5cbiAgXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuICBcdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG4gIFx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG4gIFx0XHRtYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG4gIFx0XHR0aGlzLl9tYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIE1hcmtlclxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqIEBha2EgTC5NYXJrZXJcclxuICAgKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuICBcdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG4gIFx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcbiAgXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuICBcdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG4gIFx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG4gIFx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG4gIFx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuICBcdFx0dGl0bGU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICdNYXJrZXInXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UuXHJcbiAgXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG4gIFx0XHRhbHQ6ICdNYXJrZXInLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcbiAgXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRcdG9wYWNpdHk6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcbiAgXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcbiAgXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG4gIFx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuICBcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXAgd2lsbCBwYW4gd2hlbmV2ZXIgdGhlIG1hcmtlciBpcyBmb2N1c2VkICh2aWFcclxuICBcdFx0Ly8gZS5nLiBwcmVzc2luZyBgdGFiYCBvbiB0aGUga2V5Ym9hcmQpIHRvIGVuc3VyZSB0aGUgbWFya2VyIGlzXHJcbiAgXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuICBcdFx0YXV0b1Bhbk9uRm9jdXM6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG4gIFx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG4gIFx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG4gIFx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcbiAgXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcbiAgXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG4gIFx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKlxyXG4gIFx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gIFx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuICBcdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG4gIFx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcbiAgXHR9LFxyXG5cclxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gIFx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcbiAgXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcbiAgXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG4gIFx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuICBcdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuICBcdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuICBcdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcbiAgXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuICBcdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG4gIFx0XHRcdHRoaXMub24oe1xyXG4gIFx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcbiAgXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG4gIFx0XHRcdG9uKGljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG4gIFx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93KSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuICBcdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG5cclxuICBcdFx0aWYgKGFkZEljb24pIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuICBcdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9mZih7XHJcbiAgXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuICBcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcbiAgXHRcdFx0b2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5faWNvbik7XHJcbiAgXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG4gIFx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuICBcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0YWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHRpZiAoTWFya2VyRHJhZykge1xyXG4gIFx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG4gIFx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuICBcdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuICBcdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5PbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGljb25PcHRzID0gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuICBcdFx0dmFyIHNpemUgPSBpY29uT3B0cy5pY29uU2l6ZSA/IHRvUG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogdG9Qb2ludCgwLCAwKTtcclxuICBcdFx0dmFyIGFuY2hvciA9IGljb25PcHRzLmljb25BbmNob3IgPyB0b1BvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogdG9Qb2ludCgwLCAwKTtcclxuXHJcbiAgXHRcdG1hcC5wYW5JbnNpZGUodGhpcy5fbGF0bG5nLCB7XHJcbiAgXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuICBcdFx0XHRwYWRkaW5nQm90dG9tUmlnaHQ6IHNpemUuc3VidHJhY3QoYW5jaG9yKVxyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUGF0aFxuICAgKiBAYWthIEwuUGF0aFxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAgICpcbiAgICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gICAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICAgKi9cblxuICB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUGF0aCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdHN0cm9rZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG4gIFx0XHQvLyBTdHJva2UgY29sb3JcbiAgXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cbiAgXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG4gIFx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG4gIFx0XHR3ZWlnaHQ6IDMsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuICBcdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICBcdFx0ZGFzaEFycmF5OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcbiAgXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdGZpbGw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuICBcdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuICBcdFx0ZmlsbENvbG9yOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRcdC8vIEZpbGwgb3BhY2l0eS5cbiAgXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cbiAgXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cbiAgXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuICBcdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuICBcdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG4gIFx0XHR0aGlzLl9yZXNldCgpO1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuICBcdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcbiAgXHRcdHRoaXMuX3Byb2plY3QoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcbiAgXHRcdCAgKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlIHx8IDApO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIENpcmNsZU1hcmtlclxuICAgKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAgICovXG5cbiAgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuICBcdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcbiAgXHRcdHJhZGl1czogMTBcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG4gIFx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdHRoaXMucmVkcmF3KCk7XG5cbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cbiAgXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBcdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgXHR9LFxuXG4gIFx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuICBcdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuICBcdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuICBcdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG4gIFx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBDaXJjbGVcbiAgICogQGFrYSBMLkNpcmNsZVxuICAgKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICAgKlxuICAgKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gIFx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuICBcdFx0XHRvcHRpb25zID0gZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG4gIFx0XHR9XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuICBcdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG4gIFx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuICBcdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICBcdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cbiAgXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcbiAgXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcbiAgXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG4gIFx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG4gIFx0fSxcblxuICBcdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuICBcdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcbiAgXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuICBcdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcbiAgXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcbiAgXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG4gIFx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuICBcdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuICBcdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuICBcdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG4gIFx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cbiAgXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4gIC8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuICAvLyBAYWx0ZXJuYXRpdmVcbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4gIC8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4gIC8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuICBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBQb2x5bGluZVxuICAgKiBAYWthIEwuUG9seWxpbmVcbiAgICogQGluaGVyaXRzIFBhdGhcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAgICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdFszNC4wNCwgLTExOC4yXVxuICAgKiBdO1xuICAgKlxuICAgKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gICAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICAgKiBcdFtbNDAuNzgsIC03My45MV0sXG4gICAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAgICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICAgKiBdO1xuICAgKiBgYGBcbiAgICovXG5cblxuICB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcbiAgXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cbiAgXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuICBcdFx0bm9DbGlwOiBmYWxzZVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuICBcdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cbiAgXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuICBcdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuICBcdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cbiAgXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcbiAgXHRcdCAgICBjbG9zZXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICBcdFx0ICAgIHAxLCBwMjtcblxuICBcdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG4gIFx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG4gIFx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cbiAgXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gIFx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcbiAgXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0aWYgKG1pblBvaW50KSB7XG4gIFx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBtaW5Qb2ludDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBwb2x5bGluZUNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG4gIFx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2ZcbiAgXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuICBcdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cbiAgXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuICBcdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuICBcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuICBcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcbiAgXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHQgICAgZmxhdCA9IGlzRmxhdChsYXRsbmdzKTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX3JpbmdzID0gW107XG4gIFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG4gIFx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcbiAgXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuICBcdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG4gIFx0XHRdKTtcbiAgXHR9LFxuXG4gIFx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcbiAgXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcbiAgXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcbiAgXHRcdCAgICBpLCByaW5nO1xuXG4gIFx0XHRpZiAoZmxhdCkge1xuICBcdFx0XHRyaW5nID0gW107XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuICBcdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cbiAgXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcbiAgXHRcdFx0XHRzZWdtZW50ID0gY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuICBcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cbiAgXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG4gIFx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG4gIFx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuICBcdFx0XHRcdFx0aysrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG4gIFx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcbiAgXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydHNbaV0gPSBzaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcbiAgXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG4gIFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG4gIFx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gIFx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRpZiAocG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbiAgLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4gIC8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4gIC8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuICBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cbiAgUG9seWxpbmUuX2ZsYXQgPSBfZmxhdDtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9seWdvblxuICAgKiBAYWthIEwuUG9seWdvblxuICAgKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAgICpcbiAgICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICAgKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gICAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogXTtcbiAgICogYGBgXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAgICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogICBdLFxuICAgKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAgICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICAgKiAgIF1cbiAgICogXTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWVcbiAgXHR9LFxuXG4gIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIFBvbHlnb24uXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHBvbHlnb25DZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG4gIFx0fSxcblxuICBcdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG4gIFx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuICBcdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuICBcdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcbiAgXHRcdFx0cmVzdWx0LnBvcCgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcbiAgXHRcdGlmIChpc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcbiAgXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuICBcdH0sXG5cbiAgXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcbiAgXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG4gIFx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGNsaXBwZWQgPSBjbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcbiAgXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcbiAgXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBhcnRbal07XG4gIFx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG4gIFx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuICBcdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcbiAgXHR9XG5cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBHZW9KU09OXHJcbiAgICogQGFrYSBMLkdlb0pTT05cclxuICAgKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAgICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gICAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAgICogXHR9XHJcbiAgICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICAgKiB9KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuICBcdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcbiAgXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG4gIFx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICBcdCAqIFx0cmV0dXJuIHt9XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcbiAgXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuICBcdCAqIFx0cmV0dXJuIHRydWU7XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcbiAgXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gbWFya2Vyc0luaGVyaXRPcHRpb25zOiBCb29sZWFuID0gZmFsc2VcclxuICBcdCAqIFdoZXRoZXIgZGVmYXVsdCBNYXJrZXJzIGZvciBcIlBvaW50XCIgdHlwZSBGZWF0dXJlcyBpbmhlcml0IGZyb20gZ3JvdXAgb3B0aW9ucy5cclxuICBcdCAqL1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdGlmIChnZW9qc29uKSB7XHJcbiAgXHRcdFx0dGhpcy5hZGREYXRhKGdlb2pzb24pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkRGF0YSggPEdlb0pTT04+IGRhdGEgKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuICBcdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcbiAgXHRcdHZhciBmZWF0dXJlcyA9IGlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuICBcdFx0ICAgIGksIGxlbiwgZmVhdHVyZTtcclxuXHJcbiAgXHRcdGlmIChmZWF0dXJlcykge1xyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHQvLyBvbmx5IGFkZCB0aGlzIGlmIGdlb21ldHJ5IG9yIGdlb21ldHJpZXMgYXJlIHNldCBhbmQgbm90IG51bGxcclxuICBcdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuICBcdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5hZGREYXRhKGZlYXR1cmUpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKGdlb2pzb24pKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghbGF5ZXIpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuICBcdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG4gIFx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG4gIFx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXI/ICk6IHRoaXNcclxuICBcdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuICBcdC8vIElmIGBsYXllcmAgaXMgb21pdHRlZCwgdGhlIHN0eWxlIG9mIGFsbCBmZWF0dXJlcyBpbiB0aGUgY3VycmVudCBsYXllciBpcyByZXNldC5cclxuICBcdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcbiAgXHRcdGxheWVyLm9wdGlvbnMgPSBleHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuICBcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyBzdHlsZXMgb2YgR2VvSlNPTiB2ZWN0b3IgbGF5ZXJzIHdpdGggdGhlIGdpdmVuIHN0eWxlIGZ1bmN0aW9uLlxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgc3R5bGUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldExheWVyU3R5bGU6IGZ1bmN0aW9uIChsYXllciwgc3R5bGUpIHtcclxuICBcdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcbiAgXHRcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdFx0c3R5bGUgPSBzdHlsZShsYXllci5mZWF0dXJlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcbiAgLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG4gIC8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4gIC8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuICBcdCAgICBjb29yZHMgPSBnZW9tZXRyeSA/IGdlb21ldHJ5LmNvb3JkaW5hdGVzIDogbnVsbCxcclxuICBcdCAgICBsYXllcnMgPSBbXSxcclxuICBcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG4gIFx0ICAgIF9jb29yZHNUb0xhdExuZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZyxcclxuICBcdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcbiAgXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcblxyXG4gIFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcbiAgXHRjYXNlICdQb2ludCc6XHJcbiAgXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG4gIFx0XHRyZXR1cm4gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG4gIFx0XHRcdGxheWVycy5wdXNoKF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG4gIFx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuICBcdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ1BvbHlnb24nOlxyXG4gIFx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuICBcdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBfY29vcmRzVG9MYXRMbmcpO1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHZhciBnZW9MYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcbiAgXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuICBcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG4gIFx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0XHRpZiAoZ2VvTGF5ZXIpIHtcclxuICBcdFx0XHRcdGxheWVycy5wdXNoKGdlb0xheWVyKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcbiAgXHRjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5LmZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGZlYXR1cmVMYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9tZXRyeS5mZWF0dXJlc1tpXSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRcdGlmIChmZWF0dXJlTGF5ZXIpIHtcclxuICBcdFx0XHRcdGxheWVycy5wdXNoKGZlYXR1cmVMYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0ZGVmYXVsdDpcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXJGbiwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gcG9pbnRUb0xheWVyRm4gP1xyXG4gIFx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuICBcdFx0bmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJzSW5oZXJpdE9wdGlvbnMgJiYgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbiAgLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbiAgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcbiAgXHRyZXR1cm4gbmV3IExhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbiAgLy8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4gIC8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuICAvLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcbiAgXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuICBcdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcbiAgXHRcdFx0KF9jb29yZHNUb0xhdExuZyB8fCBjb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcbiAgXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBsYXRsbmdzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG4gIFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG4gIFx0XHRbZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIGZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4sIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbiAgLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuICAvLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG4gIFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdC8vIENoZWNrIGZvciBmbGF0IGFycmF5cyByZXF1aXJlZCB0byBlbnN1cmUgdW5iYWxhbmNlZCBhcnJheXMgYXJlIGNvcnJlY3RseSBjb252ZXJ0ZWQgaW4gcmVjdXJzaW9uXHJcbiAgXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG4gIFx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBpc0ZsYXQobGF0bG5nc1tpXSkgPyAwIDogbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcbiAgXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xyXG4gIFx0XHRjb29yZHMucHVzaChjb29yZHNbMF0uc2xpY2UoKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvb3JkcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcbiAgXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcbiAgXHRcdGV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuICBcdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbjogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbiAgZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb24pIHtcclxuICBcdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuICBcdFx0cmV0dXJuIGdlb2pzb247XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG4gIFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuICBcdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuICBcdH07XHJcbiAgfVxyXG5cclxuICB2YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdQb2ludCcsXHJcbiAgXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXJrZXJcclxuICAvLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG4gIE1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG4gIENpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuICBDaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvbHlsaW5lXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuICBQb2x5bGluZS5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgbXVsdGkgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9seWdvblxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuICBQb2x5Z29uLmluY2x1ZGUoe1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHZhciBob2xlcyA9ICFpc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcbiAgXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFpc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG4gIFx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG4gIFx0XHRpZiAoIWhvbGVzKSB7XHJcbiAgXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuICBMYXllckdyb3VwLmluY2x1ZGUoe1xyXG4gIFx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIFx0Ly8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHJcbiAgXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy50b011bHRpUG9pbnQocHJlY2lzaW9uKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcbiAgXHRcdCAgICBqc29ucyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG4gIFx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKTtcclxuICBcdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG4gIFx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG4gIFx0XHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcbiAgXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG4gIFx0XHRcdFx0XHRpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdFx0anNvbnMucHVzaChmZWF0dXJlKTtcclxuICBcdFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuICBcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICBcdFx0XHRmZWF0dXJlczoganNvbnNcclxuICBcdFx0fTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbiAgLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuICAvLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuICAvLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuICB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XG5cbiAgLypcclxuICAgKiBAY2xhc3MgSW1hZ2VPdmVybGF5XHJcbiAgICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBpbWFnZVVybCA9ICdodHRwczovL21hcHMubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAgICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICAgKiBMLmltYWdlT3ZlcmxheShpbWFnZVVybCwgaW1hZ2VCb3VuZHMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG4gIFx0XHRvcGFjaXR5OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG4gIFx0XHRhbHQ6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcbiAgXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGltYWdlLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgaW1hZ2UgcGl4ZWwgZGF0YS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcbiAgXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG4gIFx0XHR6SW5kZXg6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG4gIFx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuICBcdFx0dGhpcy5fcmVzZXQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG4gIFx0XHRpZiAoc3R5bGVPcHRzLm9wYWNpdHkpIHtcclxuICBcdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIG92ZXJsYXlzLlxyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRvQmFjayh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuICBcdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuICBcdHNldEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGV2ZW50cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgodmFsdWU6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuICBcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnSU1HJztcclxuICBcdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogY3JlYXRlJDEoJ2ltZycpO1xyXG5cclxuICBcdFx0YWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcbiAgXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuICBcdFx0aW1nLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuICBcdFx0aW1nLm9ubG9hZCA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG4gIFx0XHRpbWcub25lcnJvciA9IGJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuICBcdFx0XHR0aGlzLl91cmwgPSBpbWcuc3JjO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuICBcdFx0aW1nLmFsdCA9IHRoaXMub3B0aW9ucy5hbHQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZShlLnpvb20pLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuICBcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG4gIFx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuICBcdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuICBcdFx0c2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuICBcdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuICBcdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0c2V0T3BhY2l0eSh0aGlzLl9pbWFnZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGZhaWxzIHRvIGxvYWQgaXRzIGltYWdlXHJcbiAgXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aGlzLl91cmwgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIEltYWdlT3ZlcmxheS5cclxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzLmdldENlbnRlcigpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbiAgLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG4gIHZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gICAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICAgKlxyXG4gICAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAgICogSFRNTDUgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAgICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gICAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG4gIFx0XHQvLyBPbiBzb21lIGJyb3dzZXJzIGF1dG9wbGF5IHdpbGwgb25seSB3b3JrIHdpdGggYG11dGVkOiB0cnVlYFxyXG4gIFx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuICBcdFx0bG9vcDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIHNhdmUgYXNwZWN0IHJhdGlvIGFmdGVyIHRoZSBwcm9qZWN0aW9uLlxyXG4gIFx0XHQvLyBSZWxldmFudCBmb3Igc3VwcG9ydGVkIGJyb3dzZXJzLiBTZWUgW2Jyb3dzZXIgY29tcGF0aWJpbGl0eV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL29iamVjdC1maXQpXHJcbiAgXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbXV0ZWQ6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgb24gbXV0ZSB3aGVuIGxvYWRlZC5cclxuICBcdFx0bXV0ZWQ6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwbGF5c0lubGluZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gTW9iaWxlIGJyb3dzZXJzIHdpbGwgcGxheSB0aGUgdmlkZW8gcmlnaHQgd2hlcmUgaXQgaXMgaW5zdGVhZCBvZiBvcGVuIGl0IHVwIGluIGZ1bGxzY3JlZW4gbW9kZS5cclxuICBcdFx0cGxheXNJbmxpbmU6IHRydWVcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcbiAgXHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCd2aWRlbycpO1xyXG5cclxuICBcdFx0YWRkQ2xhc3ModmlkLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IGFkZENsYXNzKHZpZCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcbiAgXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcclxuICBcdFx0dmlkLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuICBcdFx0dmlkLm9ubG9hZGVkZGF0YSA9IGJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuICBcdFx0aWYgKHdhc0VsZW1lbnRTdXBwbGllZCkge1xyXG4gIFx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcbiAgXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuICBcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNvdXJjZUVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuX3VybCA9IChzb3VyY2VFbGVtZW50cy5sZW5ndGggPiAwKSA/IHNvdXJjZXMgOiBbdmlkLnNyY107XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMua2VlcEFzcGVjdFJhdGlvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2aWQuc3R5bGUsICdvYmplY3RGaXQnKSkge1xyXG4gIFx0XHRcdHZpZC5zdHlsZVsnb2JqZWN0Rml0J10gPSAnZmlsbCc7XHJcbiAgXHRcdH1cclxuICBcdFx0dmlkLmF1dG9wbGF5ID0gISF0aGlzLm9wdGlvbnMuYXV0b3BsYXk7XHJcbiAgXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuICBcdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcbiAgXHRcdHZpZC5wbGF5c0lubGluZSA9ICEhdGhpcy5vcHRpb25zLnBsYXlzSW5saW5lO1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3VybC5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHZhciBzb3VyY2UgPSBjcmVhdGUkMSgnc291cmNlJyk7XHJcbiAgXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuICBcdFx0XHR2aWQuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MVmlkZW9FbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuICBcdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuICAvLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcblxyXG4gIGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIFNWR092ZXJsYXlcbiAgICogQGFrYSBMLlNWR092ZXJsYXlcbiAgICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICAgKlxuICAgKiBVc2VkIHRvIGxvYWQsIGRpc3BsYXkgYW5kIHByb3ZpZGUgRE9NIGFjY2VzcyB0byBhbiBTVkcgZmlsZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxuICAgKlxuICAgKiBBbiBTVkcgb3ZlcmxheSB1c2VzIHRoZSBbYDxzdmc+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvc3ZnKSBlbGVtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICAgKiBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIDIwMCAyMDBcIik7XG4gICAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gICAqIHZhciBzdmdFbGVtZW50Qm91bmRzID0gWyBbIDMyLCAtMTMwIF0sIFsgMTMsIC0xMDAgXSBdO1xuICAgKiBMLnN2Z092ZXJsYXkoc3ZnRWxlbWVudCwgc3ZnRWxlbWVudEJvdW5kcykuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG4gIFx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsID0gdGhpcy5faW1hZ2UgPSB0aGlzLl91cmw7XG5cbiAgXHRcdGFkZENsYXNzKGVsLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhlbCwgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cblxuICBcdFx0ZWwub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gIFx0XHRlbC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG4gIFx0fVxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IFNWR0VsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYFNWR0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudClcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnN2Z092ZXJsYXkoc3ZnOiBTdHJpbmd8U1ZHRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBTVkdPdmVybGF5IG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbiAgLy8gQSB2aWV3Qm94IGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBvbiB0aGUgU1ZHIGVsZW1lbnQgdG8gem9vbSBpbiBhbmQgb3V0IHByb3Blcmx5LlxuXG4gIGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgU1ZHT3ZlcmxheShlbCwgYm91bmRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIERpdk92ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gICAqIEJhc2UgbW9kZWwgZm9yIEwuUG9wdXAgYW5kIEwuVG9vbHRpcC4gSW5oZXJpdCBmcm9tIGl0IGZvciBjdXN0b20gb3ZlcmxheXMgbGlrZSBwbHVnaW5zLlxyXG4gICAqL1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuICB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgcG9wdXAvdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgbW91c2UgZXZlbnRzLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxyXG4gIFx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBvc2l0aW9uLlxyXG4gIFx0XHRvZmZzZXQ6IFswLCAwXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIG92ZXJsYXkuXHJcbiAgXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9IHVuZGVmaW5lZFxyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uID0gJydcclxuICBcdFx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBvdmVybGF5IHdoaWxlIGluaXRpYWxpemluZy4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlXHJcbiAgXHRcdC8vIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBvdmVybGF5LlxyXG4gIFx0XHRjb250ZW50OiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcbiAgXHRcdGlmIChvcHRpb25zICYmIChvcHRpb25zIGluc3RhbmNlb2YgTGF0TG5nIHx8IGlzQXJyYXkob3B0aW9ucykpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcob3B0aW9ucyk7XHJcbiAgXHRcdFx0c2V0T3B0aW9ucyh0aGlzLCBzb3VyY2UpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY29udGVudCkge1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRlbnQgPSB0aGlzLm9wdGlvbnMuY29udGVudDtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAvYC5vcGVuVG9vbHRpcCh0b29sdGlwKWAuXHJcbiAgXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7XHJcbiAgXHRcdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgb3ZlcmxheS5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAuY2xvc2VQb3B1cChwb3B1cClgL2AuY2xvc2VUb29sdGlwKHRvb2x0aXApYFxyXG4gIFx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG4gIFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGUobGF5ZXI/OiBMYXllcik6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgb3ZlcmxheSBib3VuZCB0byBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYGxheWVyLnRvZ2dsZVBvcHVwKClgL2AudG9nZ2xlVG9vbHRpcCgpYC5cclxuICBcdHRvZ2dsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLmNsb3NlKCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGhpcy5fcHJlcGFyZU9wZW4oKTtcclxuXHJcbiAgXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcbiAgXHRcdFx0dGhpcy5vcGVuT24obGF5ZXIuX21hcCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuICBcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQocmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgXHQvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuICBcdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgY29udGFpbmVyIG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgb3ZlcmxheSBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBvdmVybGF5IGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG4gIFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBvdmVybGF5IGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuICBcdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcHJlcGFyZSBib3VuZCBvdmVybGF5IHRvIG9wZW46IHVwZGF0ZSBsYXRsbmcgcG9zIC8gY29udGVudCBzb3VyY2UgKGZvciBGZWF0dXJlR3JvdXApXHJcbiAgXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0aWYgKCFzb3VyY2UuX21hcCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuICBcdFx0XHRzb3VyY2UgPSBudWxsO1xyXG4gIFx0XHRcdHZhciBsYXllcnMgPSB0aGlzLl9zb3VyY2UuX2xheWVycztcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiBsYXllcnMpIHtcclxuICBcdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuICBcdFx0XHRcdFx0c291cmNlID0gbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICghc291cmNlKSB7IHJldHVybiBmYWxzZTsgfSAvLyBVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllci5cclxuXHJcbiAgXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghbGF0bG5nKSB7XHJcbiAgXHRcdFx0aWYgKHNvdXJjZS5nZXRDZW50ZXIpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRMYXRMbmcoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRCb3VuZHMpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGV0Yy4uLilcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuICBcdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICBcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgXHRcdC8vIEBzZWN0aW9uIERpdk92ZXJsYXkgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBjb250ZW50dXBkYXRlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuICBcdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuICBcdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuICBcdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBvdmVybGF5IGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbMCwgMF07XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIGNvbnRlbnQsIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcbiAgXHRcdGlmICghKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpKSB7XHJcbiAgXHRcdFx0b3ZlcmxheSA9IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF0bG5nKSB7XHJcbiAgXHRcdFx0b3ZlcmxheS5zZXRMYXRMbmcobGF0bG5nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIExheWVyLmluY2x1ZGUoe1xyXG4gIFx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBvbGQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG4gIFx0XHRpZiAob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykge1xyXG4gIFx0XHRcdHNldE9wdGlvbnMob3ZlcmxheSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0b3ZlcmxheS5fc291cmNlID0gdGhpcztcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvdmVybGF5ID0gKG9sZCAmJiAhb3B0aW9ucykgPyBvbGQgOiBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMsIHRoaXMpO1xyXG4gIFx0XHRcdG92ZXJsYXkuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb3B1cFxyXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAgICogQGFrYSBMLlBvcHVwXHJcbiAgICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gICAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gICAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQSBwb3B1cCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICAgKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gICAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gICAqIFx0Lm9wZW5PbihtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqIG9yXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgcG9wdXAgPSBMLnBvcHVwKGxhdGxuZywge2NvbnRlbnQ6ICc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6ICdwb3B1cFBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcbiAgXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcbiAgXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcbiAgXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuICBcdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG4gIFx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG4gIFx0XHQvLyBUaGUgc2Nyb2xsYWJsZSBjb250YWluZXIgY2FuIGJlIHN0eWxlZCB1c2luZyB0aGVcclxuICBcdFx0Ly8gYGxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRgIENTUyBjbGFzcyBzZWxlY3Rvci5cclxuICBcdFx0bWF4SGVpZ2h0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcbiAgXHRcdC8vIHRvIGZpdCB0aGUgb3BlbmVkIHBvcHVwLlxyXG4gIFx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG4gIFx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBtYXBcclxuICBcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IFBvaW50ID0gbnVsbFxyXG4gIFx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcbiAgXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuICBcdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nOiBbNSwgNV0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG4gIFx0XHQvLyBvZmYgb2YgdGhlIHNjcmVlbiB3aGlsZSBpdCBpcyBvcGVuLlxyXG4gIFx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIENvbnRyb2xzIHRoZSBwcmVzZW5jZSBvZiBhIGNsb3NlIGJ1dHRvbiBpbiB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcbiAgXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAgXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xvc2VPbkVzY2FwZUtleTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuICBcdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG4gIFx0XHRjbG9zZU9uRXNjYXBlS2V5OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcbiAgXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcbiAgXHRcdC8vIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRoZSBtYXAncyBbYGNsb3NlUG9wdXBPbkNsaWNrYF0oI21hcC1jbG9zZXBvcHVwb25jbGljaykgb3B0aW9uLlxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsYXNzTmFtZTogJydcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG4gIFx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuXHJcbiAgXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblxyXG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuICBcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobWFwLl9wb3B1cCk7XHJcbiAgXHRcdH1cclxuICBcdFx0bWFwLl9wb3B1cCA9IHRoaXM7XHJcblxyXG4gIFx0XHRyZXR1cm4gRGl2T3ZlcmxheS5wcm90b3R5cGUub3Blbk9uLmNhbGwodGhpcywgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcbiAgXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuICBcdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuICBcdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcbiAgXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcbiAgXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuICBcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG4gIFx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtcG9wdXAnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsXHJcbiAgXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuICBcdFx0XHQnIGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cclxuICBcdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuICBcdFx0dGhpcy5fY29udGVudE5vZGUgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG4gIFx0XHRvbihjb250YWluZXIsICdjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG4gIFx0XHR0aGlzLl90aXBDb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuICBcdFx0dGhpcy5fdGlwID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwJywgdGhpcy5fdGlwQ29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuICBcdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IGNyZWF0ZSQxKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTsgLy8gb3ZlcnJpZGVzIHRoZSBpbXBsaWNpdCByb2xlPWxpbmsgb2YgPGE+IGVsZW1lbnRzICM3Mzk5XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0Nsb3NlIHBvcHVwJyk7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mIzIxNTs8L3NwYW4+JztcclxuXHJcbiAgXHRcdFx0b24oY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gIFx0XHRcdFx0cHJldmVudERlZmF1bHQoZXYpO1xyXG4gIFx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG4gIFx0XHQgICAgc3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcblxyXG4gIFx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG4gIFx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG4gIFx0XHR2YXIgd2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcbiAgXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG4gIFx0XHRzdHlsZS53aWR0aCA9ICh3aWR0aCArIDEpICsgJ3B4JztcclxuICBcdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuICBcdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG4gIFx0XHR2YXIgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcclxuICBcdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcbiAgXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuICBcdFx0aWYgKG1heEhlaWdodCAmJiBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcclxuICBcdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG4gIFx0XHRcdGFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuICBcdFx0Ly8gV2UgY2FuIGVuZGxlc3NseSByZWN1cnNlIGlmIGtlZXBJblZpZXcgaXMgc2V0IGFuZCB0aGUgdmlldyByZXNldHMuXHJcbiAgXHRcdC8vIExldCdzIGd1YXJkIGFnYWluc3QgdGhhdCBieSBleGl0aW5nIGVhcmx5IGlmIHdlJ3JlIHJlc3BvbmRpbmcgdG8gb3VyIG93biBhdXRvcGFuLlxyXG4gIFx0XHRpZiAodGhpcy5fYXV0b3Bhbm5pbmcpIHtcclxuICBcdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IGZhbHNlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuICBcdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KGdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuICBcdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcbiAgXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG4gIFx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG4gIFx0XHRsYXllclBvcy5fYWRkKGdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcbiAgXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgZHggPSAwLFxyXG4gIFx0XHQgICAgZHkgPSAwO1xyXG5cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG4gIFx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcbiAgXHRcdGlmIChkeCB8fCBkeSkge1xyXG4gIFx0XHRcdC8vIFRyYWNrIHRoYXQgd2UncmUgYXV0b3Bhbm5pbmcsIGFzIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZS1yYW4gb24gbW92ZWVuZFxyXG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG4gIFx0XHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0bWFwXHJcbiAgXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG4gIFx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIC8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwucG9wdXAobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxyXG4gIHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuICBcdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAgICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICAgKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gICAqL1xyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcbiAgXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG4gIFx0XHQgIC5vcGVuT24odGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuICBcdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG4gIFx0XHRwb3B1cCA9IGFyZ3VtZW50cy5sZW5ndGggPyBwb3B1cCA6IHRoaXMuX3BvcHVwO1xyXG4gIFx0XHRpZiAocG9wdXApIHtcclxuICBcdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICAgKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICAgKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICAgKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICAgKi9cclxuXHJcbiAgLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG4gIExheWVyLmluY2x1ZGUoe1xyXG5cclxuICBcdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG4gIFx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG4gIFx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9wb3B1cCA9IHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCB0aGlzLl9wb3B1cCwgY29udGVudCwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5vbih7XHJcbiAgXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG4gIFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcbiAgXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuICBcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuICBcdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMub2ZmKHtcclxuICBcdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcbiAgXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuICBcdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG4gIFx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG4gIFx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGhpcztcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9wcmVwYXJlT3BlbihsYXRsbmcgfHwgdGhpcy5fbGF0bG5nKSkge1xyXG4gIFx0XHRcdFx0Ly8gb3BlbiB0aGUgcG9wdXAgb24gdGhlIG1hcFxyXG4gIFx0XHRcdFx0dGhpcy5fcG9wdXAub3Blbk9uKHRoaXMuX21hcCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG4gIFx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXHJcbiAgXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLmNsb3NlKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuICBcdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLnRvZ2dsZSh0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1BvcHVwT3BlbigpOiBib29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuICBcdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAodGhpcy5fcG9wdXAgPyB0aGlzLl9wb3B1cC5pc09wZW4oKSA6IGZhbHNlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuICBcdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuICBcdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCAhdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcbiAgXHRcdHN0b3AoZSk7XHJcblxyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuICBcdFx0aWYgKHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0Ly8gdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG4gIFx0XHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcclxuICBcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSB0YXJnZXQ7XHJcbiAgXHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcclxuICBcdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgVG9vbHRpcFxuICAgKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICAgKiBAYWthIEwuVG9vbHRpcFxuICAgKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHRvb2x0aXAgdG8gbWFya2VyOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRUb29sdGlwYCBtZXRob2QuXG4gICAqXG4gICAqIEEgdG9vbHRpcCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcCgpXG4gICAqIFx0LnNldExhdExuZyhsYXRsbmcpXG4gICAqIFx0LnNldENvbnRlbnQoJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJylcbiAgICogXHQuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqIG9yXG4gICAqIGBgYGpzXG4gICAqIHZhciB0b29sdGlwID0gTC50b29sdGlwKGxhdGxuZywge2NvbnRlbnQ6ICdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLid9KVxuICAgKiBcdC5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICpcbiAgICpcbiAgICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gICAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICAgKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAgICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAgICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAgICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICAgKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAgICovXG5cblxuICAvLyBAbmFtZXNwYWNlIFRvb2x0aXBcbiAgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgVG9vbHRpcCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgYmUgYWRkZWQuXG4gIFx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuICBcdFx0Ly8gT3B0aW9uYWwgb2Zmc2V0IG9mIHRoZSB0b29sdGlwIHBvc2l0aW9uLlxuICBcdFx0b2Zmc2V0OiBbMCwgMF0sXG5cbiAgXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcbiAgXHRcdC8vIERpcmVjdGlvbiB3aGVyZSB0byBvcGVuIHRoZSB0b29sdGlwLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgcmlnaHRgLCBgbGVmdGAsXG4gIFx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG4gIFx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG4gIFx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuICBcdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cbiAgXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cbiAgXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cbiAgXHRcdHN0aWNreTogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG4gIFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuICBcdFx0b3BhY2l0eTogMC45XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gIFx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cbiAgXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgXHRcdFx0dGhpcy5hZGRFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG4gIFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cbiAgXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG4gIFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcbiAgXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcbiAgXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUpO1xuXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2xlYWZsZXQtdG9vbHRpcC0nICsgc3RhbXAodGhpcykpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG4gIFx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHR2YXIgc3ViWCwgc3ViWSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICBcdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcbiAgXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcbiAgXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuICBcdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG4gIFx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQ7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSAwO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICBcdFx0XHRzdWJYID0gMDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoO1xuICBcdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG4gIFx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuICBcdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuICBcdFx0XHRzdWJYID0gMDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fVxuXG4gIFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuICBcdFx0cmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgXHR9LFxuXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuICBcdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcbiAgXHR9LFxuXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIC8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuICAvLyBAYWx0ZXJuYXRpdmVcbiAgLy8gQGZhY3RvcnkgTC50b29sdGlwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBgVG9vbHRpcGAgb2JqZWN0IGdpdmVuIGBsYXRsbmdgIHdoZXJlIHRoZSB0b29sdGlwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXG4gIHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICBcdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xuICB9O1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgTWFwLmluY2x1ZGUoe1xuXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG4gIFx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcbiAgXHRcdCAgLm9wZW5Pbih0aGlzKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gIFx0XHR0b29sdGlwLmNsb3NlKCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBMYXllclxuICAgKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICAgKlxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICAgKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIC8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuICBMYXllci5pbmNsdWRlKHtcblxuICBcdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuICBcdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG4gIFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG4gIFx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG4gIFx0XHRcdHRoaXMudW5iaW5kVG9vbHRpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG4gIFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cbiAgXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcbiAgXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gIFx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcbiAgXHRcdCAgICBldmVudHMgPSB7XG4gIFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG4gIFx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG4gIFx0XHQgICAgfTtcbiAgXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuICBcdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuICBcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHR9XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuICBcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG4gIFx0XHR9XG4gIFx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuICBcdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcbiAgXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWVkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cbiAgXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKGxhdGxuZykge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkpIHtcbiAgXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSB0aGlzO1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9wcmVwYXJlT3BlbihsYXRsbmcpKSB7XG4gIFx0XHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG4gIFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5vcGVuT24odGhpcy5fbWFwKTtcblxuICBcdFx0XHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIodGhpcyk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuICBcdFx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciwgdGhpcyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuICBcdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlmIGl0IGlzIG9wZW4uXG4gIFx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcC5jbG9zZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cbiAgXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl90b29sdGlwLnRvZ2dsZSh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXG4gIFx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuICBcdHNldFRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0VG9vbHRpcCgpOiBUb29sdGlwXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuICBcdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuICBcdH0sXG5cbiAgXHRfYWRkRm9jdXNMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmdldEVsZW1lbnQpIHtcbiAgXHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyKHRoaXMpO1xuICBcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuICBcdFx0XHR0aGlzLmVhY2hMYXllcih0aGlzLl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIsIHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcbiAgXHRcdGlmIChlbCkge1xuICBcdFx0XHRvbihlbCwgJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGxheWVyO1xuICBcdFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcbiAgXHRcdFx0fSwgdGhpcyk7XG4gIFx0XHRcdG9uKGVsLCAnYmx1cicsIHRoaXMuY2xvc2VUb29sdGlwLCB0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGVsID0gdHlwZW9mIGxheWVyLmdldEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgbGF5ZXIuZ2V0RWxlbWVudCgpO1xuICBcdFx0aWYgKGVsKSB7XG4gIFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lci5pZCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuXG4gIFx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXApIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJZiB0aGUgbWFwIGlzIG1vdmluZywgd2Ugd2lsbCBzaG93IHRoZSB0b29sdGlwIGFmdGVyIGl0J3MgZG9uZS5cbiAgXHRcdGlmICh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpICYmICF0aGlzLl9vcGVuT25jZUZsYWcpIHtcbiAgXHRcdFx0dGhpcy5fb3Blbk9uY2VGbGFnID0gdHJ1ZTtcbiAgXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuICBcdFx0XHR0aGlzLl9tYXAub25jZSgnbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR0aGF0Ll9vcGVuT25jZUZsYWcgPSBmYWxzZTtcbiAgXHRcdFx0XHR0aGF0Ll9vcGVuVG9vbHRpcChlKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuICBcdFx0dGhpcy5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuICBcdH0sXG5cbiAgXHRfbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG4gIFx0XHRcdGNvbnRhaW5lclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUub3JpZ2luYWxFdmVudCk7XG4gIFx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuICBcdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBEaXZJY29uXG4gICAqIEBha2EgTC5EaXZJY29uXG4gICAqIEBpbmhlcml0cyBJY29uXG4gICAqXG4gICAqIFJlcHJlc2VudHMgYSBsaWdodHdlaWdodCBpY29uIGZvciBtYXJrZXJzIHRoYXQgdXNlcyBhIHNpbXBsZSBgPGRpdj5gXG4gICAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICAgKiAvLyB5b3UgY2FuIHNldCAubXktZGl2LWljb24gc3R5bGVzIGluIENTU1xuICAgKlxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICAgKi9cblxuICB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAc2VjdGlvblxuICBcdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcbiAgXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cbiAgXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG4gIFx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuICBcdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmd8SFRNTEVsZW1lbnQgPSAnJ1xuICBcdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC4gQWx0ZXJuYXRpdmVseSxcbiAgXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG4gIFx0XHRodG1sOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cbiAgXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcbiAgXHRcdGJnUG9zOiBudWxsLFxuXG4gIFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuICBcdH0sXG5cbiAgXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuICBcdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdGlmIChvcHRpb25zLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gIFx0XHRcdGVtcHR5KGRpdik7XG4gIFx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcbiAgXHRcdFx0dmFyIGJnUG9zID0gdG9Qb2ludChvcHRpb25zLmJnUG9zKTtcbiAgXHRcdFx0ZGl2LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICgtYmdQb3MueCkgKyAncHggJyArICgtYmdQb3MueSkgKyAncHgnO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cbiAgXHRcdHJldHVybiBkaXY7XG4gIFx0fSxcblxuICBcdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmRpdkljb24ob3B0aW9uczogRGl2SWNvbiBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGRpdkljb24ob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbiAgfVxuXG4gIEljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5HcmlkTGF5ZXJcbiAgICpcbiAgICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICAgKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gICAqXG4gICAqXG4gICAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAgICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gICAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gICAqXG4gICAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAgICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gICAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gICAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICAgKiAgICAgICAgIHZhciBlcnJvcjtcbiAgICpcbiAgICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gICAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICAgKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICAgKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gICAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gICAqXG4gICAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICAgKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICAgKiAgICAgICAgIH0sIDEwMDApO1xuICAgKlxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uXG4gICAqL1xuXG5cbiAgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcbiAgXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cbiAgXHRcdHRpbGVTaXplOiAyNTYsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuICBcdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cbiAgXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG4gIFx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuICBcdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cbiAgXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuICBcdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuICBcdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cbiAgXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cbiAgXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG4gIFx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuICBcdFx0ekluZGV4OiAxLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG4gIFx0XHRib3VuZHM6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuICBcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG4gIFx0XHRtaW5ab29tOiAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuICBcdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuICBcdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcbiAgXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cbiAgXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcbiAgXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcbiAgXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cbiAgXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcbiAgXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cbiAgXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG4gIFx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuICBcdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cbiAgXHRcdG5vV3JhcDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuICBcdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG4gIFx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cbiAgXHRcdGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuICBcdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuICBcdFx0a2VlcEJ1ZmZlcjogMlxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuICBcdFx0dGhpcy5fbGV2ZWxzID0ge307XG4gIFx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG4gIFx0XHR0aGlzLl9yZXNldFZpZXcoKTsgLy8gaW1wbGljaXQgX3VwZGF0ZSgpIGNhbGxcbiAgXHR9LFxuXG4gIFx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcbiAgXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCB0aWxlIGxheWVycy5cbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIFtvcGFjaXR5XSgjZ3JpZGxheWVyLW9wYWNpdHkpIG9mIHRoZSBncmlkIGxheWVyLlxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gIFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuICBcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG4gIFx0aXNMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXc6IHRoaXNcbiAgXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cbiAgXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRoaXMuX21hcC5nZXRab29tKCkpO1xuICBcdFx0XHRpZiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKSB7XG4gIFx0XHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSB7XG4gIFx0XHRcdHZpZXdwcmVyZXNldDogdGhpcy5faW52YWxpZGF0ZUFsbCxcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG4gIFx0XHRcdHpvb206IHRoaXMuX3Jlc2V0VmlldyxcbiAgXHRcdFx0bW92ZWVuZDogdGhpcy5fb25Nb3ZlRW5kXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuICBcdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcbiAgXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcbiAgXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSB0aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuICBcdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcbiAgXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG4gIFx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuICBcdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cbiAgXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIFx0fSxcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcbiAgXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cbiAgXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG4gIFx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuICBcdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG4gIFx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuICBcdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuICBcdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuICBcdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG4gIFx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG4gIFx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuICBcdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cbiAgXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcbiAgXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcbiAgXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuICBcdFx0XHRpZiAoZmFkZSA8IDEpIHtcbiAgXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuICBcdFx0aWYgKG5leHRGcmFtZSkge1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcbiAgXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uT3BhcXVlVGlsZTogZmFsc2VGbixcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuICBcdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcbiAgXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cbiAgXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIFx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHR6ID0gTnVtYmVyKHopO1xuICBcdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG4gIFx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG4gIFx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcbiAgXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcbiAgXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuICBcdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0aWYgKCFsZXZlbCkge1xuICBcdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG4gIFx0XHRcdGxldmVsLmVsID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cbiAgXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG4gIFx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG4gIFx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cbiAgXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cbiAgXHRcdFx0ZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cbiAgXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cbiAgXHRcdHJldHVybiBsZXZlbDtcbiAgXHR9LFxuXG4gIFx0X29uVXBkYXRlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfb25SZW1vdmVMZXZlbDogZmFsc2VGbixcblxuICBcdF9vbkNyZWF0ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGtleSwgdGlsZTtcblxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICBcdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuICBcdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3JkcztcbiAgXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuICBcdFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0XHR9XG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG4gIFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoTnVtYmVyKHopKTtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cbiAgXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuICBcdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG4gIFx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcbiAgXHRcdCAgICB6MiA9IHogLSAxLFxuICBcdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuICBcdFx0Y29vcmRzMi56ID0gK3oyO1xuXG4gIFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkczIpLFxuICBcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gIFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLl9yZXRhaW5QYXJlbnQoeDIsIHkyLCB6MiwgbWluWm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuICBcdFx0XHRmb3IgKHZhciBqID0gMiAqIHk7IGogPCAyICogeSArIDI7IGorKykge1xuXG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcbiAgXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG4gIFx0XHRcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpLFxuICBcdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdFx0XHRjb250aW51ZTtcblxuICBcdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICBcdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xuICBcdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcbiAgXHR9LFxuXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcbiAgXHR9LFxuXG4gIFx0X2NsYW1wWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9ucy5taW5OYXRpdmVab29tO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXhOYXRpdmVab29tO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gem9vbTtcbiAgXHR9LFxuXG4gIFx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG4gIFx0XHR2YXIgdGlsZVpvb20gPSBNYXRoLnJvdW5kKHpvb20pO1xuICBcdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG4gIFx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcbiAgXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aWxlWm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB0aWxlWm9vbUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMudXBkYXRlV2hlblpvb21pbmcgJiYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSk7XG5cbiAgXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cbiAgXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuICBcdFx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG4gIFx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcbiAgXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cbiAgXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGUoY2VudGVyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghbm9QcnVuZSkge1xuICBcdFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG4gIFx0XHRcdC8vIGEgem9vbSBhbmltIG9yIGEgcGluY2ggZ2VzdHVyZVxuICBcdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtcyhjZW50ZXIsIHpvb20pO1xuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG4gIFx0XHQgICAgdHJhbnNsYXRlID0gbGV2ZWwub3JpZ2luLm11bHRpcGx5Qnkoc2NhbGUpXG4gIFx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cbiAgXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG4gIFx0XHRcdHNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbihsZXZlbC5lbCwgdHJhbnNsYXRlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG4gIFx0XHQgICAgdGlsZVNpemUgPSB0aGlzLl90aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuICBcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG4gIFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG4gIFx0XHRdO1xuICBcdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG4gIFx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcbiAgXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueSlcbiAgXHRcdF07XG4gIFx0fSxcblxuICBcdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb20gPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpIDogbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuICBcdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcbiAgXHRcdCAgICBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcblxuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcbiAgXHR9LFxuXG4gIFx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cbiAgXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cbiAgXHRcdGlmICh0aGlzLl90aWxlWm9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVx0Ly8gaWYgb3V0IG9mIG1pbnpvb20vbWF4em9vbVxuXG4gIFx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG4gIFx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG4gIFx0XHQgICAgdGlsZUNlbnRlciA9IHRpbGVSYW5nZS5nZXRDZW50ZXIoKSxcbiAgXHRcdCAgICBxdWV1ZSA9IFtdLFxuICBcdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuICBcdFx0ICAgIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG4gIFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuICBcdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG4gIFx0XHRpZiAoIShpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLngpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG4gIFx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LnkpKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlcycpOyB9XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuICBcdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKG5ldyBQb2ludChjLngsIGMueSkpKSB7XG4gIFx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuICBcdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cbiAgXHRcdGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5fdGlsZVpvb20pID4gMSkgeyB0aGlzLl9zZXRWaWV3KGNlbnRlciwgem9vbSk7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cbiAgXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW4ueDsgaSA8PSB0aWxlUmFuZ2UubWF4Lng7IGkrKykge1xuICBcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG4gIFx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuICBcdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG4gIFx0XHRcdFx0aWYgKHRpbGUpIHtcbiAgXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG4gIFx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICBcdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG4gIFx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuICBcdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICBcdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuICBcdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG4gIFx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcbiAgXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG4gIFx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuICBcdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuICBcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuICBcdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuICBcdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcbiAgXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG4gIFx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG4gIFx0fSxcblxuICBcdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG4gIFx0fSxcblxuICBcdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICBcdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG4gIFx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcbiAgXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuICBcdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG4gIFx0XHRyZXR1cm4gW253LCBzZV07XG4gIFx0fSxcblxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgYnAgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXG4gIFx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcbiAgXHRcdFx0Ym91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBib3VuZHM7XG4gIFx0fSxcbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcbiAgXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xuICBcdH0sXG5cbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuICBcdF9rZXlUb1RpbGVDb29yZHM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG4gIFx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG4gIFx0XHRjb29yZHMueiA9ICtrWzJdO1xuICBcdFx0cmV0dXJuIGNvb3JkcztcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuICBcdFx0cmVtb3ZlKHRpbGUuZWwpO1xuXG4gIFx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cbiAgXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcbiAgXHRcdFx0dGlsZTogdGlsZS5lbCxcbiAgXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcbiAgXHRcdGFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuICBcdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuICBcdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgXHRcdHRpbGUub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuXG4gIFx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuICBcdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG4gIFx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcbiAgXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBiaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cbiAgXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG4gIFx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuICBcdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuICBcdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG4gIFx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG4gIFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuICBcdFx0fVxuXG4gIFx0XHRzZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuICBcdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG4gIFx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuICBcdFx0XHRlbDogdGlsZSxcbiAgXHRcdFx0Y29vcmRzOiBjb29yZHMsXG4gIFx0XHRcdGN1cnJlbnQ6IHRydWVcbiAgXHRcdH07XG5cbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcbiAgXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG4gIFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG4gIFx0XHRcdHRpbGU6IHRpbGUsXG4gIFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG4gIFx0XHRpZiAoZXJyKSB7XG4gIFx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG4gIFx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuICBcdFx0XHRcdGVycm9yOiBlcnIsXG4gIFx0XHRcdFx0dGlsZTogdGlsZSxcbiAgXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gIFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuICBcdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcbiAgXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWVycikge1xuICBcdFx0XHRhZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG4gIFx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuICBcdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuICBcdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG4gIFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcbiAgXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICBcdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG4gIFx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG4gIFx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuICBcdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuICBcdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuICBcdFx0XHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcbiAgXHR9LFxuXG4gIFx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgUG9pbnQoXG4gIFx0XHRcdHRoaXMuX3dyYXBYID8gd3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG4gIFx0XHRcdHRoaXMuX3dyYXBZID8gd3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuICBcdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcbiAgXHRcdHJldHVybiBuZXdDb29yZHM7XG4gIFx0fSxcblxuICBcdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcbiAgXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG4gIFx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG4gIFx0fSxcblxuICBcdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuICBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAgICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gICAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICAgKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gTm90ZSB0aGF0IG1vc3QgdGlsZSBzZXJ2ZXJzIHJlcXVpcmUgYXR0cmlidXRpb24sIHdoaWNoIHlvdSBjYW4gc2V0IHVuZGVyIGBMYXllcmAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLnRpbGVMYXllcignaHR0cHM6Ly90aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZz97Zm9vfScsIHtmb286ICdiYXInLCBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJ30pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqICdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS9ibGFibGEve3p9L3t4fS97eX17cn0ucG5nJ1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYHtzfWAgbWVhbnMgb25lIG9mIHRoZSBhdmFpbGFibGUgc3ViZG9tYWlucyAodXNlZCBzZXF1ZW50aWFsbHkgdG8gaGVscCB3aXRoIGJyb3dzZXIgcGFyYWxsZWwgcmVxdWVzdHMgcGVyIGRvbWFpbiBsaW1pdGF0aW9uOyBzdWJkb21haW4gdmFsdWVzIGFyZSBzcGVjaWZpZWQgaW4gb3B0aW9uczsgYGFgLCBgYmAgb3IgYGNgIGJ5IGRlZmF1bHQsIGNhbiBiZSBvbWl0dGVkKSwgYHt6fWAg4oCUIHpvb20gbGV2ZWwsIGB7eH1gIGFuZCBge3l9YCDigJQgdGlsZSBjb29yZGluYXRlcy4gYHtyfWAgY2FuIGJlIHVzZWQgdG8gYWRkIFwiJmNvbW1hdDsyeFwiIHRvIHRoZSBVUkwgdG8gbG9hZCByZXRpbmEgdGlsZXMuXHJcbiAgICpcclxuICAgKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuXHJcbiAgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxyXG4gIFx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuICBcdFx0bWluWm9vbTogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuICBcdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG4gIFx0XHRtYXhab29tOiAxOCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuICBcdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAgXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcbiAgXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuICBcdFx0em9vbU9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcbiAgXHRcdHRtczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG4gIFx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG4gIFx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiByZWZlcnJlclBvbGljeTogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC5cclxuICBcdFx0Ly8gVGhpcyBtYXkgYmUgbmVlZGVkIGlmIHlvdXIgbWFwJ3MgcmVuZGVyaW5nIGNvbnRleHQgaGFzIGEgc3RyaWN0IGRlZmF1bHQgYnV0IHlvdXIgdGlsZSBwcm92aWRlciBleHBlY3RzIGEgdmFsaWQgcmVmZXJyZXJcclxuICBcdFx0Ly8gKGUuZy4gdG8gdmFsaWRhdGUgYW4gQVBJIHRva2VuKS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0hUTUxJbWFnZUVsZW1lbnQucmVmZXJyZXJQb2xpY3ldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L3JlZmVycmVyUG9saWN5KSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0cmVmZXJyZXJQb2xpY3k6IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG4gIFx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuICBcdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG4gIFx0XHRcdGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG4gIFx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcbiAgXHRcdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSAtIDEpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuICBcdFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tICsgMSk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG4gIFx0XHR9IGVsc2UgaWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIG1heFpvb20gaXMgZ3RlIG1pblpvb21cclxuICBcdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIG1pblpvb20gaXMgbHRlIG1heFpvb21cclxuICBcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub24oJ3RpbGV1bmxvYWQnLCB0aGlzLl9vblRpbGVSZW1vdmUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgbGF5ZXIncyBVUkwgdGVtcGxhdGUgYW5kIHJlZHJhd3MgaXQgKHVubGVzcyBgbm9SZWRyYXdgIGlzIHNldCB0byBgdHJ1ZWApLlxyXG4gIFx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG4gIFx0Ly8gdGhlIG5vUmVkcmF3IHBhcmFtZXRlciBpcyBzZXQgdG8gZmFsc2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcbiAgXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0bm9SZWRyYXcgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcbiAgXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgb3ZlcnJpZGVzIEdyaWRMYXllcidzIFtgY3JlYXRlVGlsZSgpYF0oI2dyaWRsYXllci1jcmVhdGV0aWxlKVxyXG4gIFx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG4gIFx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG4gIFx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuICBcdFx0b24odGlsZSwgJ2xvYWQnLCBiaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuICBcdFx0b24odGlsZSwgJ2Vycm9yJywgYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBmb3IgdGhpcyBuZXcgb3B0aW9uIHdlIGZvbGxvdyB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvclxyXG4gIFx0XHQvLyBtb3JlIGNsb3NlbHkgYnkgb25seSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSB3aGVuIHN0cmluZ1xyXG4gIFx0XHRpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeSA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHR0aWxlLnJlZmVycmVyUG9saWN5ID0gdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5O1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBUaGUgYWx0IGF0dHJpYnV0ZSBpcyBzZXQgdG8gdGhlIGVtcHR5IHN0cmluZyxcclxuICBcdFx0Ly8gYWxsb3dpbmcgc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoZSBkZWNvcmF0aXZlIGltYWdlIHRpbGVzLlxyXG4gIFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvV0FJL3R1dG9yaWFscy9pbWFnZXMvZGVjb3JhdGl2ZS9cclxuICBcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWwtYXJpYS8jZWwtaW1nLWVtcHR5LWFsdFxyXG4gIFx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuICBcdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aWxlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gIFx0Ly8gQHVuaW5oZXJpdGFibGVcclxuICBcdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG4gIFx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcbiAgXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcbiAgXHRcdFx0eDogY29vcmRzLngsXHJcbiAgXHRcdFx0eTogY29vcmRzLnksXHJcbiAgXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcbiAgXHRcdH07XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG4gIFx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG4gIFx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGVtcGxhdGUodGhpcy5fdXJsLCBleHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG4gIFx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG4gIFx0XHRcdHNldFRpbWVvdXQoYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuICBcdFx0fVxyXG4gIFx0XHRkb25lKGUsIHRpbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuICBcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG4gIFx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuICBcdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuICBcdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuICBcdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcbiAgXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpLCB0aWxlO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcbiAgXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG4gIFx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0dGlsZS5vbmVycm9yID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuICBcdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG4gIFx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG4gIFx0XHRcdFx0XHRyZW1vdmUodGlsZSk7XHJcbiAgXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuICBcdFx0XHRcdFx0Ly8gQGV2ZW50IHRpbGVhYm9ydDogVGlsZUV2ZW50XHJcbiAgXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuICBcdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlYWJvcnQnLCB7XHJcbiAgXHRcdFx0XHRcdFx0dGlsZTogdGlsZSxcclxuICBcdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG4gIFx0XHRcdFx0XHR9KTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcbiAgXHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBlbXB0eUltYWdlVXJsKTtcclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gZW1wdHlJbWFnZVVybCkpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gICAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gICAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gICAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gICAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICAgKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuICBcdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuICBcdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcbiAgXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cHM6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuICBcdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuICBcdFx0c2VydmljZTogJ1dNUycsXHJcbiAgXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuICBcdFx0bGF5ZXJzOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG4gIFx0XHRzdHlsZXM6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG4gIFx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuICBcdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG4gIFx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuICBcdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcbiAgXHRcdHZlcnNpb246ICcxLjEuMSdcclxuICBcdH0sXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG4gIFx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG4gIFx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuICBcdFx0Y3JzOiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG4gIFx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG4gIFx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuICBcdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcclxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG4gIFx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuICBcdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuICBcdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG4gIFx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuICBcdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG4gIFx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuICBcdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcbiAgXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuICBcdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuICBcdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcbiAgXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcbiAgXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuICBcdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuICBcdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiB1cmwgK1xyXG4gIFx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuICBcdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuICBcdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcbiAgXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcbiAgXHRcdGlmICghbm9SZWRyYXcpIHtcclxuICBcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbiAgdGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcblxuICAvKlxuICAgKiBAY2xhc3MgUmVuZGVyZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5SZW5kZXJlclxuICAgKlxuICAgKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICAgKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICAgKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAgICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICAgKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gICAqXG4gICAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gICAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gICAqL1xuXG4gIHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcbiAgXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuICBcdFx0cGFkZGluZzogMC4xXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0c3RhbXAodGhpcyk7XG4gIFx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cbiAgXHRcdFx0Ly8gYWx3YXlzIGtlZXAgdHJhbnNmb3JtLW9yaWdpbiBhcyAwIDBcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG4gIFx0XHR0aGlzLl9kZXN0cm95Q29udGFpbmVyKCk7XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IHtcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcbiAgXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuICBcdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG4gIFx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuICBcdH0sXG5cbiAgXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG4gIFx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblxuICBcdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKGN1cnJlbnRDZW50ZXJQb2ludClcbiAgXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG4gIFx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICBcdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcbiAgXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcbiAgXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG4gIFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gIFx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDYW52YXNcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5DYW52YXNcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vY2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICAgKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gICAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAgICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAgICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG4gIFx0XHR0b2xlcmFuY2U6IDBcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuICBcdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuICBcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuICBcdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuICBcdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cbiAgXHRcdHRoaXMuX2RyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuICBcdFx0Y29udGFpbmVyWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fY3R4O1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBsYXllcjtcbiAgXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICBcdFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG4gIFx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG4gIFx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG4gIFx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuICBcdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG4gIFx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICBcdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cbiAgXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuICBcdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuICBcdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG4gIFx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcbiAgXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuICBcdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcbiAgXHRcdFx0bGF5ZXI6IGxheWVyLFxuICBcdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcbiAgXHRcdFx0bmV4dDogbnVsbFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG4gIFx0XHRpZiAocHJldikge1xuICBcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcbiAgXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcbiAgXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuICBcdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxcbiAgXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuICBcdFx0XHQgICAgZGFzaFZhbHVlLFxuICBcdFx0XHQgICAgaTtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcbiAgXHRcdFx0XHQvLyBJZ25vcmUgZGFzaCBhcnJheSBjb250YWluaW5nIGludmFsaWQgbGVuZ3Roc1xuICBcdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuICBcdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcbiAgXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG4gIFx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcbiAgXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHR9LFxuXG4gIFx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcbiAgXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0dGhpcy5fY3R4LnNhdmUoKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG4gIFx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cbiAgXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuICBcdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuICBcdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG4gIFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuICBcdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmIChjbG9zZWQpIHtcbiAgXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuICBcdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG4gIFx0fSxcblxuICBcdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHguc2F2ZSgpO1xuICBcdFx0XHRjdHguc2NhbGUoMSwgcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGN0eC5iZWdpblBhdGgoKTtcbiAgXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHgucmVzdG9yZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuICBcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuICBcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuICBcdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcbiAgXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICBcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuICBcdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG4gIFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuICBcdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuICBcdFx0XHRjdHguc3Ryb2tlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuICBcdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG4gIFx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG4gIFx0XHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHRoaXMuX2ZpcmVFdmVudChjbGlja2VkTGF5ZXIgPyBbY2xpY2tlZExheWVyXSA6IGZhbHNlLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG4gIFx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcbiAgXHR9LFxuXG5cbiAgXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG4gIFx0XHRpZiAobGF5ZXIpIHtcbiAgXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG4gIFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICBcdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG4gIFx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG4gIFx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3JcbiAgXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcbiAgXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG4gIFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcbiAgXHRcdHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH0sIHRoaXMpLCAzMik7XG4gIFx0fSxcblxuICBcdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcbiAgXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuICBcdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2UgaWYgKG5leHQpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuICBcdFx0XHQvLyBzaW5nbGUgZW50cnlcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuICBcdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gbnVsbDtcbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2UgaWYgKHByZXYpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG5cbiAgXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICAvKlxuICAgKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICAgKi9cblxuXG4gIHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdHRyeSB7XG4gIFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0XHR9O1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gIFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzcyNzlcbiAgXHR9XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0fTtcbiAgfSkoKTtcblxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICpcbiAgICpcbiAgICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICovXG5cbiAgLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbiAgdmFyIHZtbE1peGluID0ge1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuICBcdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG4gIFx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHRyZW1vdmUoY29udGFpbmVyKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcbiAgXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuICBcdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuICBcdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgXHRcdFx0aWYgKCFzdHJva2UpIHtcbiAgXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4JztcbiAgXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IGlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuICBcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICBcdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcbiAgXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG4gIFx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGlmICghZmlsbCkge1xuICBcdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcbiAgXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gIFx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuICBcdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuICBcdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuU1ZHXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL3N2ZyksIFNWRyBpcyBub3RcbiAgICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAgICpcbiAgICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAgICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAgICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICAgKiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICAgKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gICAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gICAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG4gIFx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICBcdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG4gIFx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG4gIFx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuICBcdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgXHRcdFx0YWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cbiAgXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJlbW92ZShsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGxheWVyLl9wcm9qZWN0KCk7XG4gIFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG4gIFx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcbiAgXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcbiAgXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cbiAgXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG4gIFx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcbiAgXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcbiAgXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcbiAgXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuICBcdH0sXG5cbiAgXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9CYWNrKGxheWVyLl9wYXRoKTtcbiAgXHR9XG4gIH0pO1xuXG4gIGlmIChCcm93c2VyLnZtbCkge1xuICBcdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbiAgfVxuXG4gIC8vIEBuYW1lc3BhY2UgU1ZHXG4gIC8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICBNYXAuaW5jbHVkZSh7XG4gIFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG4gIFx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcbiAgXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG4gIFx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuICBcdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuICBcdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG4gIFx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuICBcdFx0aWYgKCFyZW5kZXJlcikge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG4gIFx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG4gIFx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAgICovXG5cbiAgLypcbiAgICogQGNsYXNzIFJlY3RhbmdsZVxuICAgKiBAYWthIEwuUmVjdGFuZ2xlXG4gICAqIEBpbmhlcml0cyBQb2x5Z29uXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICAgKlxuICAgKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICAgKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICAgKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKi9cblxuXG4gIHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuICBcdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG4gIFx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG4gIFx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcbiAgXHR9LFxuXG4gIFx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuICBcdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcbiAgXHRcdHJldHVybiBbXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuICBcdFx0XTtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIFNWRy5jcmVhdGUgPSBjcmVhdGU7XG4gIFNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cbiAgR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG4gIEdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbiAgR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG4gIEdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3JkcztcbiAgR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG4gIEdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG4gIEdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gICAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG4gIFx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG4gIFx0Ym94Wm9vbTogdHJ1ZVxuICB9KTtcblxuICB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcbiAgXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmUodGhpcy5fcGFuZSk7XG4gIFx0XHRkZWxldGUgdGhpcy5fcGFuZTtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG4gIFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuICBcdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuICBcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuICBcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcblxuICBcdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0b24oZG9jdW1lbnQsIHtcbiAgXHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG4gIFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gIFx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcbiAgXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cbiAgXHRcdFx0dGhpcy5fYm94ID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuICBcdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG4gIFx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cbiAgXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuICBcdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gIFx0fSxcblxuICBcdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fYm94KTtcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcbiAgXHRcdH1cblxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cbiAgXHRcdG9mZihkb2N1bWVudCwge1xuICBcdFx0XHRjb250ZXh0bWVudTogc3RvcCxcbiAgXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuICBcdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9maW5pc2goKTtcblxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cbiAgXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuICBcdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cbiAgXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuICBcdFx0dGhpcy5fbWFwXG4gIFx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuICBcdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gIFx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuICBcdFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuICAvLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcbiAgXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcbiAgXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcbiAgXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcbiAgXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy9cbiAgLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4gIC8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbiAgLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vIGBgYGpzXG4gIC8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuICAvLyBgYGBcbiAgLy9cbiAgLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuICAvLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cbiAgXHRkcmFnZ2luZzogdHJ1ZSxcblxuICBcdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuICBcdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcbiAgXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuICBcdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcbiAgXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gIFx0aW5lcnRpYTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuICBcdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cbiAgXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuICBcdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG4gIFx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG4gIFx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cbiAgXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuICBcdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuICBcdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG4gIFx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuICBcdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG4gIFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuICBcdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG4gIFx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcbiAgXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG4gIFx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcbiAgXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cbiAgXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxuICB9KTtcblxuICB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcbiAgXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHRcdH0sIHRoaXMpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcbiAgXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcbiAgXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcbiAgXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG4gIFx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcbiAgXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpO1xuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcbiAgXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuICBcdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcbiAgXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG4gIFx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0bWFwXG4gIFx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcbiAgXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gIFx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcbiAgXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9tYXBcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuICBcdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuICBcdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cbiAgXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG4gIFx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcbiAgXHR9LFxuXG4gIFx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcbiAgXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cbiAgXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuICBcdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuICBcdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cbiAgXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcbiAgXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcbiAgXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcbiAgXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcbiAgXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuICBcdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG4gIFx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG4gIFx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG4gIFx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG4gIFx0XHRpZiAobm9JbmVydGlhKSB7XG4gIFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuICBcdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuICBcdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuICBcdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuICBcdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuICBcdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cbiAgXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG4gIFx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuICBcdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG4gIFx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG4gIFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG4gIFx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG4gIFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG4gIFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcbiAgXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG4gIFx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAgLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG5cbiAgLypcbiAgICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG4gIFx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG4gIFx0a2V5Ym9hcmQ6IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG4gIFx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG4gIFx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbiAgfSk7XG5cbiAgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG4gIFx0a2V5Q29kZXM6IHtcbiAgXHRcdGxlZnQ6ICAgIFszN10sXG4gIFx0XHRyaWdodDogICBbMzldLFxuICBcdFx0ZG93bjogICAgWzQwXSxcbiAgXHRcdHVwOiAgICAgIFszOF0sXG4gIFx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuICBcdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cbiAgXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuICBcdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cbiAgXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuICBcdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG4gIFx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcbiAgXHRcdH1cblxuICBcdFx0b24oY29udGFpbmVyLCB7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG4gIFx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cbiAgXHRcdH0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9tYXAub24oe1xuICBcdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuICBcdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuICBcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0dGhpcy5fbWFwLm9mZih7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3NcbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gIFx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIFx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuICBcdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuICBcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuICBcdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG4gIFx0fSxcblxuICBcdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuICBcdH0sXG5cbiAgXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gIFx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuICBcdH0sXG5cbiAgXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuICBcdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG4gIFx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvZmZzZXQ7XG5cbiAgXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuICBcdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG4gIFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuICBcdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG4gIFx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG4gIFx0XHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KHRvUG9pbnQob2Zmc2V0KSwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuICBcdFx0XHRcdFx0dmFyIG5ld0xhdExuZyA9IG1hcC53cmFwTGF0TG5nKG1hcC51bnByb2plY3QobWFwLnByb2plY3QobWFwLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSkpO1xuICBcdFx0XHRcdFx0bWFwLnBhblRvKG5ld0xhdExuZyk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcbiAgXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG4gIFx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0c3RvcChlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuICAvLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gTW91c2Ugd2hlZWwgb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuICBcdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cbiAgXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuICBcdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG4gIFx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG4gIFx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG4gIFx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuICBcdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcbiAgXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG4gIFx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG4gIFx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbiAgfSk7XG5cbiAgdmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSA9IDA7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBkZWx0YSA9IGdldFdoZWVsRGVsdGEoZSk7XG5cbiAgXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcbiAgXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcbiAgXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cbiAgXHRcdHN0b3AoZSk7XG4gIFx0fSxcblxuICBcdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuICBcdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cbiAgXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuICBcdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuICBcdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcbiAgXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcbiAgXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cbiAgXHRcdHRoaXMuX2RlbHRhID0gMDtcbiAgXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cbiAgXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4gIC8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuXG4gIC8qXG4gICAqIEwuTWFwLlRhcEhvbGQgaXMgdXNlZCB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50IG9uIGxvbmcgaG9sZCxcbiAgICogd2hpY2ggb3RoZXJ3aXNlIGlzIG5vdCBmaXJlZCBieSBtb2JpbGUgU2FmYXJpLlxuICAgKi9cblxuICB2YXIgdGFwSG9sZERlbGF5ID0gNjAwO1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gdGFwSG9sZDogQm9vbGVhblxuICBcdC8vIEVuYWJsZXMgc2ltdWxhdGlvbiBvZiBgY29udGV4dG1lbnVgIGV2ZW50LCBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgbW9iaWxlIFNhZmFyaS5cbiAgXHR0YXBIb2xkOiBCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIuc2FmYXJpICYmIEJyb3dzZXIubW9iaWxlLFxuXG4gIFx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG4gIFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcbiAgXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cbiAgXHR0YXBUb2xlcmFuY2U6IDE1XG4gIH0pO1xuXG4gIHZhciBUYXBIb2xkID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuICBcdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG4gIFx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX2NhbmNlbCgpO1xuICBcdFx0XHRpZiAoIXRoaXMuX2lzVGFwVmFsaWQoKSkgeyByZXR1cm47IH1cblxuICBcdFx0XHQvLyBwcmV2ZW50IHNpbXVsYXRlZCBtb3VzZSBldmVudHMgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3RvdWNoLWV2ZW50cy8jbW91c2UtZXZlbnRzXG4gIFx0XHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gIFx0XHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9jYW5jZWxDbGlja1ByZXZlbnQpO1xuICBcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcbiAgXHRcdH0sIHRoaXMpLCB0YXBIb2xkRGVsYXkpO1xuXG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2NhbmNlbENsaWNrUHJldmVudDogZnVuY3Rpb24gY2FuY2VsQ2xpY2tQcmV2ZW50KCkge1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGNhbmNlbENsaWNrUHJldmVudCk7XG4gIFx0fSxcblxuICBcdF9jYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuICBcdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuICBcdH0sXG5cbiAgXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG4gIFx0fSxcblxuICBcdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICBcdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwge1xuICBcdFx0XHRidWJibGVzOiB0cnVlLFxuICBcdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxuICBcdFx0XHR2aWV3OiB3aW5kb3csXG4gIFx0XHRcdC8vIGRldGFpbDogMSxcbiAgXHRcdFx0c2NyZWVuWDogZS5zY3JlZW5YLFxuICBcdFx0XHRzY3JlZW5ZOiBlLnNjcmVlblksXG4gIFx0XHRcdGNsaWVudFg6IGUuY2xpZW50WCxcbiAgXHRcdFx0Y2xpZW50WTogZS5jbGllbnRZLFxuICBcdFx0XHQvLyBidXR0b246IDIsXG4gIFx0XHRcdC8vIGJ1dHRvbnM6IDJcbiAgXHRcdH0pO1xuXG4gIFx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblxuICBcdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgdGFwSG9sZDogSGFuZGxlclxuICAvLyBMb25nIHRhcCBoYW5kbGVyIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgKHVzZWZ1bCBpbiBtb2JpbGUgU2FmYXJpKS5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcEhvbGQnLCBUYXBIb2xkKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG4gIFx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2ZcbiAgXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuICBcdC8vIGJyb3dzZXJzLlxuICBcdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCxcblxuICBcdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuICBcdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cbiAgXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbiAgfSk7XG5cbiAgdmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuICBcdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG4gIFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuICBcdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcbiAgXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuICBcdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG4gIFx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cbiAgXHRcdG1hcC5fc3RvcCgpO1xuXG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcbiAgXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuICBcdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cbiAgXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG4gIFx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG4gIFx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG4gIFx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuICBcdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuICBcdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcbiAgXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG4gIFx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG4gIFx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSk7XG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuICBcdFx0dmFyIG1vdmVGbiA9IGJpbmQobWFwLl9tb3ZlLCBtYXAsIHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSwge3BpbmNoOiB0cnVlLCByb3VuZDogZmFsc2V9LCB1bmRlZmluZWQpO1xuICBcdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuICBcdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuICBcdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4gIC8vIFRvdWNoIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG5cbiAgTWFwLkJveFpvb20gPSBCb3hab29tO1xuICBNYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuICBNYXAuRHJhZyA9IERyYWc7XG4gIE1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuICBNYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuICBNYXAuVGFwSG9sZCA9IFRhcEhvbGQ7XG4gIE1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbiAgZXhwb3J0cy5Cb3VuZHMgPSBCb3VuZHM7XG4gIGV4cG9ydHMuQnJvd3NlciA9IEJyb3dzZXI7XG4gIGV4cG9ydHMuQ1JTID0gQ1JTO1xuICBleHBvcnRzLkNhbnZhcyA9IENhbnZhcztcbiAgZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XG4gIGV4cG9ydHMuQ2lyY2xlTWFya2VyID0gQ2lyY2xlTWFya2VyO1xuICBleHBvcnRzLkNsYXNzID0gQ2xhc3M7XG4gIGV4cG9ydHMuQ29udHJvbCA9IENvbnRyb2w7XG4gIGV4cG9ydHMuRGl2SWNvbiA9IERpdkljb247XG4gIGV4cG9ydHMuRGl2T3ZlcmxheSA9IERpdk92ZXJsYXk7XG4gIGV4cG9ydHMuRG9tRXZlbnQgPSBEb21FdmVudDtcbiAgZXhwb3J0cy5Eb21VdGlsID0gRG9tVXRpbDtcbiAgZXhwb3J0cy5EcmFnZ2FibGUgPSBEcmFnZ2FibGU7XG4gIGV4cG9ydHMuRXZlbnRlZCA9IEV2ZW50ZWQ7XG4gIGV4cG9ydHMuRmVhdHVyZUdyb3VwID0gRmVhdHVyZUdyb3VwO1xuICBleHBvcnRzLkdlb0pTT04gPSBHZW9KU09OO1xuICBleHBvcnRzLkdyaWRMYXllciA9IEdyaWRMYXllcjtcbiAgZXhwb3J0cy5IYW5kbGVyID0gSGFuZGxlcjtcbiAgZXhwb3J0cy5JY29uID0gSWNvbjtcbiAgZXhwb3J0cy5JbWFnZU92ZXJsYXkgPSBJbWFnZU92ZXJsYXk7XG4gIGV4cG9ydHMuTGF0TG5nID0gTGF0TG5nO1xuICBleHBvcnRzLkxhdExuZ0JvdW5kcyA9IExhdExuZ0JvdW5kcztcbiAgZXhwb3J0cy5MYXllciA9IExheWVyO1xuICBleHBvcnRzLkxheWVyR3JvdXAgPSBMYXllckdyb3VwO1xuICBleHBvcnRzLkxpbmVVdGlsID0gTGluZVV0aWw7XG4gIGV4cG9ydHMuTWFwID0gTWFwO1xuICBleHBvcnRzLk1hcmtlciA9IE1hcmtlcjtcbiAgZXhwb3J0cy5NaXhpbiA9IE1peGluO1xuICBleHBvcnRzLlBhdGggPSBQYXRoO1xuICBleHBvcnRzLlBvaW50ID0gUG9pbnQ7XG4gIGV4cG9ydHMuUG9seVV0aWwgPSBQb2x5VXRpbDtcbiAgZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcbiAgZXhwb3J0cy5Qb2x5bGluZSA9IFBvbHlsaW5lO1xuICBleHBvcnRzLlBvcHVwID0gUG9wdXA7XG4gIGV4cG9ydHMuUG9zQW5pbWF0aW9uID0gUG9zQW5pbWF0aW9uO1xuICBleHBvcnRzLlByb2plY3Rpb24gPSBpbmRleDtcbiAgZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG4gIGV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgZXhwb3J0cy5TVkcgPSBTVkc7XG4gIGV4cG9ydHMuU1ZHT3ZlcmxheSA9IFNWR092ZXJsYXk7XG4gIGV4cG9ydHMuVGlsZUxheWVyID0gVGlsZUxheWVyO1xuICBleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuICBleHBvcnRzLlRyYW5zZm9ybWF0aW9uID0gVHJhbnNmb3JtYXRpb247XG4gIGV4cG9ydHMuVXRpbCA9IFV0aWw7XG4gIGV4cG9ydHMuVmlkZW9PdmVybGF5ID0gVmlkZW9PdmVybGF5O1xuICBleHBvcnRzLmJpbmQgPSBiaW5kO1xuICBleHBvcnRzLmJvdW5kcyA9IHRvQm91bmRzO1xuICBleHBvcnRzLmNhbnZhcyA9IGNhbnZhcztcbiAgZXhwb3J0cy5jaXJjbGUgPSBjaXJjbGU7XG4gIGV4cG9ydHMuY2lyY2xlTWFya2VyID0gY2lyY2xlTWFya2VyO1xuICBleHBvcnRzLmNvbnRyb2wgPSBjb250cm9sO1xuICBleHBvcnRzLmRpdkljb24gPSBkaXZJY29uO1xuICBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbiAgZXhwb3J0cy5mZWF0dXJlR3JvdXAgPSBmZWF0dXJlR3JvdXA7XG4gIGV4cG9ydHMuZ2VvSlNPTiA9IGdlb0pTT047XG4gIGV4cG9ydHMuZ2VvSnNvbiA9IGdlb0pzb247XG4gIGV4cG9ydHMuZ3JpZExheWVyID0gZ3JpZExheWVyO1xuICBleHBvcnRzLmljb24gPSBpY29uO1xuICBleHBvcnRzLmltYWdlT3ZlcmxheSA9IGltYWdlT3ZlcmxheTtcbiAgZXhwb3J0cy5sYXRMbmcgPSB0b0xhdExuZztcbiAgZXhwb3J0cy5sYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcztcbiAgZXhwb3J0cy5sYXllckdyb3VwID0gbGF5ZXJHcm91cDtcbiAgZXhwb3J0cy5tYXAgPSBjcmVhdGVNYXA7XG4gIGV4cG9ydHMubWFya2VyID0gbWFya2VyO1xuICBleHBvcnRzLnBvaW50ID0gdG9Qb2ludDtcbiAgZXhwb3J0cy5wb2x5Z29uID0gcG9seWdvbjtcbiAgZXhwb3J0cy5wb2x5bGluZSA9IHBvbHlsaW5lO1xuICBleHBvcnRzLnBvcHVwID0gcG9wdXA7XG4gIGV4cG9ydHMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xuICBleHBvcnRzLnNldE9wdGlvbnMgPSBzZXRPcHRpb25zO1xuICBleHBvcnRzLnN0YW1wID0gc3RhbXA7XG4gIGV4cG9ydHMuc3ZnID0gc3ZnO1xuICBleHBvcnRzLnN2Z092ZXJsYXkgPSBzdmdPdmVybGF5O1xuICBleHBvcnRzLnRpbGVMYXllciA9IHRpbGVMYXllcjtcbiAgZXhwb3J0cy50b29sdGlwID0gdG9vbHRpcDtcbiAgZXhwb3J0cy50cmFuc2Zvcm1hdGlvbiA9IHRvVHJhbnNmb3JtYXRpb247XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4gIGV4cG9ydHMudmlkZW9PdmVybGF5ID0gdmlkZW9PdmVybGF5O1xuXG4gIHZhciBvbGRMID0gd2luZG93Lkw7XG4gIGV4cG9ydHMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICBcdHdpbmRvdy5MID0gb2xkTDtcbiAgXHRyZXR1cm4gdGhpcztcbiAgfVxuICAvLyBBbHdheXMgZXhwb3J0IHVzIHRvIHdpbmRvdyBnbG9iYWwgKHNlZSAjMjM2NClcbiAgd2luZG93LkwgPSBleHBvcnRzO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0LXNyYy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ0aGlzIiwiZXhwb3J0cyIsInN0ciIsImkiLCJpbmRleCIsInpvb20iLCJzY2FsZSIsInN0eWxlIiwidHlwZSIsInJlbW92ZSIsImNvbnRyb2wiLCJwcmV2ZW50T3V0bGluZSIsImVkZ2UiLCJsYXllcnMiLCJtYXJrZXIiLCJpY29uIiwicG9wdXAiLCJ0b29sdGlwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUtBLEtBQUMsU0FBVSxRQUFRLFNBQVM7QUFDcUMsY0FBUSxPQUFPO0FB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
